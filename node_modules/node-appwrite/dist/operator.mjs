// src/operator.ts
var Condition = /* @__PURE__ */ ((Condition2) => {
  Condition2["Equal"] = "equal";
  Condition2["NotEqual"] = "notEqual";
  Condition2["GreaterThan"] = "greaterThan";
  Condition2["GreaterThanEqual"] = "greaterThanEqual";
  Condition2["LessThan"] = "lessThan";
  Condition2["LessThanEqual"] = "lessThanEqual";
  Condition2["Contains"] = "contains";
  Condition2["IsNull"] = "isNull";
  Condition2["IsNotNull"] = "isNotNull";
  return Condition2;
})(Condition || {});
var _Operator = class _Operator {
  /**
   * Constructor for Operator class.
   *
   * @param {string} method
   * @param {OperatorValues} values
   */
  constructor(method, values) {
    this.method = method;
    if (values !== void 0) {
      if (Array.isArray(values)) {
        this.values = values;
      } else {
        this.values = [values];
      }
    }
  }
  /**
   * Convert the operator object to a JSON string.
   *
   * @returns {string}
   */
  toString() {
    return JSON.stringify({
      method: this.method,
      values: this.values
    });
  }
};
/**
 * Increment a numeric attribute by a specified value.
 *
 * @param {number} value
 * @param {number} max
 * @returns {string}
 */
_Operator.increment = (value = 1, max) => {
  if (isNaN(value) || !isFinite(value)) {
    throw new Error("Value cannot be NaN or Infinity");
  }
  if (max !== void 0 && (isNaN(max) || !isFinite(max))) {
    throw new Error("Max cannot be NaN or Infinity");
  }
  const values = [value];
  if (max !== void 0) {
    values.push(max);
  }
  return new _Operator("increment", values).toString();
};
/**
 * Decrement a numeric attribute by a specified value.
 *
 * @param {number} value
 * @param {number} min
 * @returns {string}
 */
_Operator.decrement = (value = 1, min) => {
  if (isNaN(value) || !isFinite(value)) {
    throw new Error("Value cannot be NaN or Infinity");
  }
  if (min !== void 0 && (isNaN(min) || !isFinite(min))) {
    throw new Error("Min cannot be NaN or Infinity");
  }
  const values = [value];
  if (min !== void 0) {
    values.push(min);
  }
  return new _Operator("decrement", values).toString();
};
/**
 * Multiply a numeric attribute by a specified factor.
 *
 * @param {number} factor
 * @param {number} max
 * @returns {string}
 */
_Operator.multiply = (factor, max) => {
  if (isNaN(factor) || !isFinite(factor)) {
    throw new Error("Factor cannot be NaN or Infinity");
  }
  if (max !== void 0 && (isNaN(max) || !isFinite(max))) {
    throw new Error("Max cannot be NaN or Infinity");
  }
  const values = [factor];
  if (max !== void 0) {
    values.push(max);
  }
  return new _Operator("multiply", values).toString();
};
/**
 * Divide a numeric attribute by a specified divisor.
 *
 * @param {number} divisor
 * @param {number} min
 * @returns {string}
 */
_Operator.divide = (divisor, min) => {
  if (isNaN(divisor) || !isFinite(divisor)) {
    throw new Error("Divisor cannot be NaN or Infinity");
  }
  if (min !== void 0 && (isNaN(min) || !isFinite(min))) {
    throw new Error("Min cannot be NaN or Infinity");
  }
  if (divisor === 0) {
    throw new Error("Divisor cannot be zero");
  }
  const values = [divisor];
  if (min !== void 0) {
    values.push(min);
  }
  return new _Operator("divide", values).toString();
};
/**
 * Apply modulo operation on a numeric attribute.
 *
 * @param {number} divisor
 * @returns {string}
 */
_Operator.modulo = (divisor) => {
  if (isNaN(divisor) || !isFinite(divisor)) {
    throw new Error("Divisor cannot be NaN or Infinity");
  }
  if (divisor === 0) {
    throw new Error("Divisor cannot be zero");
  }
  return new _Operator("modulo", [divisor]).toString();
};
/**
 * Raise a numeric attribute to a specified power.
 *
 * @param {number} exponent
 * @param {number} max
 * @returns {string}
 */
_Operator.power = (exponent, max) => {
  if (isNaN(exponent) || !isFinite(exponent)) {
    throw new Error("Exponent cannot be NaN or Infinity");
  }
  if (max !== void 0 && (isNaN(max) || !isFinite(max))) {
    throw new Error("Max cannot be NaN or Infinity");
  }
  const values = [exponent];
  if (max !== void 0) {
    values.push(max);
  }
  return new _Operator("power", values).toString();
};
/**
 * Append values to an array attribute.
 *
 * @param {any[]} values
 * @returns {string}
 */
_Operator.arrayAppend = (values) => new _Operator("arrayAppend", values).toString();
/**
 * Prepend values to an array attribute.
 *
 * @param {any[]} values
 * @returns {string}
 */
_Operator.arrayPrepend = (values) => new _Operator("arrayPrepend", values).toString();
/**
 * Insert a value at a specific index in an array attribute.
 *
 * @param {number} index
 * @param {any} value
 * @returns {string}
 */
_Operator.arrayInsert = (index, value) => new _Operator("arrayInsert", [index, value]).toString();
/**
 * Remove a value from an array attribute.
 *
 * @param {any} value
 * @returns {string}
 */
_Operator.arrayRemove = (value) => new _Operator("arrayRemove", [value]).toString();
/**
 * Remove duplicate values from an array attribute.
 *
 * @returns {string}
 */
_Operator.arrayUnique = () => new _Operator("arrayUnique", []).toString();
/**
 * Keep only values that exist in both the current array and the provided array.
 *
 * @param {any[]} values
 * @returns {string}
 */
_Operator.arrayIntersect = (values) => new _Operator("arrayIntersect", values).toString();
/**
 * Remove values from the array that exist in the provided array.
 *
 * @param {any[]} values
 * @returns {string}
 */
_Operator.arrayDiff = (values) => new _Operator("arrayDiff", values).toString();
/**
 * Filter array values based on a condition.
 *
 * @param {Condition} condition
 * @param {any} value
 * @returns {string}
 */
_Operator.arrayFilter = (condition, value) => {
  const values = [condition, value === void 0 ? null : value];
  return new _Operator("arrayFilter", values).toString();
};
/**
 * Concatenate a value to a string or array attribute.
 *
 * @param {any} value
 * @returns {string}
 */
_Operator.stringConcat = (value) => new _Operator("stringConcat", [value]).toString();
/**
 * Replace occurrences of a search string with a replacement string.
 *
 * @param {string} search
 * @param {string} replace
 * @returns {string}
 */
_Operator.stringReplace = (search, replace) => new _Operator("stringReplace", [search, replace]).toString();
/**
 * Toggle a boolean attribute.
 *
 * @returns {string}
 */
_Operator.toggle = () => new _Operator("toggle", []).toString();
/**
 * Add days to a date attribute.
 *
 * @param {number} days
 * @returns {string}
 */
_Operator.dateAddDays = (days) => new _Operator("dateAddDays", [days]).toString();
/**
 * Subtract days from a date attribute.
 *
 * @param {number} days
 * @returns {string}
 */
_Operator.dateSubDays = (days) => new _Operator("dateSubDays", [days]).toString();
/**
 * Set a date attribute to the current date and time.
 *
 * @returns {string}
 */
_Operator.dateSetNow = () => new _Operator("dateSetNow", []).toString();
var Operator = _Operator;

export { Condition, Operator };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=operator.mjs.map