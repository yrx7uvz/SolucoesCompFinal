{"version":3,"sources":["../src/query.ts"],"names":[],"mappings":"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","sourcesContent":["type QueryTypesSingle = string | number | boolean;\nexport type QueryTypesList = string[] | number[] | boolean[] | Query[] | any[];\nexport type QueryTypes = QueryTypesSingle | QueryTypesList;\ntype AttributesTypes = string | string[];\n\n/**\n * Helper class to generate query strings.\n */\nexport class Query {\n  method: string;\n  attribute: AttributesTypes | undefined;\n  values: QueryTypesList | undefined;\n\n  /**\n   * Constructor for Query class.\n   *\n   * @param {string} method\n   * @param {AttributesTypes} attribute\n   * @param {QueryTypes} values\n   */\n  constructor(\n    method: string,\n    attribute?: AttributesTypes,\n    values?: QueryTypes\n  ) {\n    this.method = method;\n    this.attribute = attribute;\n\n    if (values !== undefined) {\n      if (Array.isArray(values)) {\n        this.values = values;\n      } else {\n        this.values = [values] as QueryTypesList;\n      }\n    }\n  }\n\n  /**\n   * Convert the query object to a JSON string.\n   *\n   * @returns {string}\n   */\n  toString(): string {\n    return JSON.stringify({\n      method: this.method,\n      attribute: this.attribute,\n      values: this.values,\n    });\n  }\n\n  /**\n   * Filter resources where attribute is equal to value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static equal = (attribute: string, value: QueryTypes): string =>\n    new Query(\"equal\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is not equal to value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static notEqual = (attribute: string, value: QueryTypes): string =>\n    new Query(\"notEqual\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is less than value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static lessThan = (attribute: string, value: QueryTypes): string =>\n    new Query(\"lessThan\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is less than or equal to value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static lessThanEqual = (attribute: string, value: QueryTypes): string =>\n    new Query(\"lessThanEqual\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is greater than value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static greaterThan = (attribute: string, value: QueryTypes): string =>\n    new Query(\"greaterThan\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is greater than or equal to value.\n   *\n   * @param {string} attribute\n   * @param {QueryTypes} value\n   * @returns {string}\n   */\n  static greaterThanEqual = (attribute: string, value: QueryTypes): string =>\n    new Query(\"greaterThanEqual\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is null.\n   *\n   * @param {string} attribute\n   * @returns {string}\n   */\n  static isNull = (attribute: string): string =>\n    new Query(\"isNull\", attribute).toString();\n\n  /**\n   * Filter resources where attribute is not null.\n   *\n   * @param {string} attribute\n   * @returns {string}\n   */\n  static isNotNull = (attribute: string): string =>\n    new Query(\"isNotNull\", attribute).toString();\n\n  /**\n   * Filter resources where attribute is between start and end (inclusive).\n   *\n   * @param {string} attribute\n   * @param {string | number} start\n   * @param {string | number} end\n   * @returns {string}\n   */\n  static between = (attribute: string, start: string | number, end: string | number): string =>\n    new Query(\"between\", attribute, [start, end] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute starts with value.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static startsWith = (attribute: string, value: string): string =>\n    new Query(\"startsWith\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute ends with value.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static endsWith = (attribute: string, value: string): string =>\n    new Query(\"endsWith\", attribute, value).toString();\n\n  /**\n   * Specify which attributes should be returned by the API call.\n   *\n   * @param {string[]} attributes\n   * @returns {string}\n   */\n  static select = (attributes: string[]): string =>\n    new Query(\"select\", undefined, attributes).toString();\n\n  /**\n   * Filter resources by searching attribute for value.\n   * A fulltext index on attribute is required for this query to work.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static search = (attribute: string, value: string): string =>\n    new Query(\"search\", attribute, value).toString();\n\n  /**\n   * Sort results by attribute descending.\n   *\n   * @param {string} attribute\n   * @returns {string}\n   */\n  static orderDesc = (attribute: string): string =>\n    new Query(\"orderDesc\", attribute).toString();\n\n  /**\n   * Sort results by attribute ascending.\n   *\n   * @param {string} attribute\n   * @returns {string}\n   */\n  static orderAsc = (attribute: string): string =>\n    new Query(\"orderAsc\", attribute).toString();\n\n  /**\n   * Sort results randomly.\n   *\n   * @returns {string}\n   */\n  static orderRandom = (): string =>\n    new Query(\"orderRandom\").toString();\n\n  /**\n   * Return results after documentId.\n   *\n   * @param {string} documentId\n   * @returns {string}\n   */\n  static cursorAfter = (documentId: string): string =>\n    new Query(\"cursorAfter\", undefined, documentId).toString();\n\n  /**\n   * Return results before documentId.\n   *\n   * @param {string} documentId\n   * @returns {string}\n   */\n  static cursorBefore = (documentId: string): string =>\n    new Query(\"cursorBefore\", undefined, documentId).toString();\n\n  /**\n   * Return only limit results.\n   *\n   * @param {number} limit\n   * @returns {string}\n   */\n  static limit = (limit: number): string =>\n    new Query(\"limit\", undefined, limit).toString();\n\n  /**\n   * Filter resources by skipping the first offset results.\n   *\n   * @param {number} offset\n   * @returns {string}\n   */\n  static offset = (offset: number): string =>\n    new Query(\"offset\", undefined, offset).toString();\n\n  /**\n   * Filter resources where attribute contains the specified value.\n   *\n   * @param {string} attribute\n   * @param {string | string[]} value\n   * @returns {string}\n   */\n  static contains = (attribute: string, value: string | any[]): string =>\n    new Query(\"contains\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute does not contain the specified value.\n   *\n   * @param {string} attribute\n   * @param {string | any[]} value\n   * @returns {string}\n   */\n  static notContains = (attribute: string, value: string | any[]): string =>\n    new Query(\"notContains\", attribute, value).toString();\n\n  /**\n   * Filter resources by searching attribute for value (inverse of search).\n   * A fulltext index on attribute is required for this query to work.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static notSearch = (attribute: string, value: string): string =>\n    new Query(\"notSearch\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute is not between start and end (exclusive).\n   *\n   * @param {string} attribute\n   * @param {string | number} start\n   * @param {string | number} end\n   * @returns {string}\n   */\n  static notBetween = (attribute: string, start: string | number, end: string | number): string =>\n    new Query(\"notBetween\", attribute, [start, end] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute does not start with value.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static notStartsWith = (attribute: string, value: string): string =>\n    new Query(\"notStartsWith\", attribute, value).toString();\n\n  /**\n   * Filter resources where attribute does not end with value.\n   *\n   * @param {string} attribute\n   * @param {string} value\n   * @returns {string}\n   */\n  static notEndsWith = (attribute: string, value: string): string =>\n    new Query(\"notEndsWith\", attribute, value).toString();\n\n  /**\n   * Filter resources where document was created before date.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  static createdBefore = (value: string): string =>\n    Query.lessThan(\"$createdAt\", value);\n\n  /**\n   * Filter resources where document was created after date.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  static createdAfter = (value: string): string =>\n    Query.greaterThan(\"$createdAt\", value);\n\n  /**\n   * Filter resources where document was created between dates.\n   *\n   * @param {string} start\n   * @param {string} end\n   * @returns {string}\n   */\n  static createdBetween = (start: string, end: string): string =>\n    Query.between(\"$createdAt\", start, end);\n\n  /**\n   * Filter resources where document was updated before date.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  static updatedBefore = (value: string): string =>\n    Query.lessThan(\"$updatedAt\", value);\n\n  /**\n   * Filter resources where document was updated after date.\n   *\n   * @param {string} value\n   * @returns {string}\n   */\n  static updatedAfter = (value: string): string =>\n    Query.greaterThan(\"$updatedAt\", value);\n\n  /**\n   * Filter resources where document was updated between dates.\n   *\n   * @param {string} start\n   * @param {string} end\n   * @returns {string}\n   */\n  static updatedBetween = (start: string, end: string): string =>\n    Query.between(\"$updatedAt\", start, end);\n\n  /**\n   * Combine multiple queries using logical OR operator.\n   *\n   * @param {string[]} queries\n   * @returns {string}\n   */\n  static or = (queries: string[]) =>\n    new Query(\"or\", undefined, queries.map((query) => JSON.parse(query))).toString();\n\n  /**\n   * Combine multiple queries using logical AND operator.\n   *\n   * @param {string[]} queries\n   * @returns {string}\n   */\n  static and = (queries: string[]) =>\n    new Query(\"and\", undefined, queries.map((query) => JSON.parse(query))).toString();\n\n  /**\n   * Filter resources where attribute is at a specific distance from the given coordinates.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @param {number} distance\n   * @param {boolean} meters\n   * @returns {string}\n   */\n  static distanceEqual = (attribute: string, values: any[], distance: number, meters: boolean = true): string =>\n    new Query(\"distanceEqual\", attribute, [[values, distance, meters]] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute is not at a specific distance from the given coordinates.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @param {number} distance\n   * @param {boolean} meters\n   * @returns {string}\n   */\n  static distanceNotEqual = (attribute: string, values: any[], distance: number, meters: boolean = true): string =>\n    new Query(\"distanceNotEqual\", attribute, [[values, distance, meters]] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute is at a distance greater than the specified value from the given coordinates.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @param {number} distance\n   * @param {boolean} meters\n   * @returns {string}\n   */\n  static distanceGreaterThan = (attribute: string, values: any[], distance: number, meters: boolean = true): string =>\n    new Query(\"distanceGreaterThan\", attribute, [[values, distance, meters]] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute is at a distance less than the specified value from the given coordinates.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @param {number} distance\n   * @param {boolean} meters\n   * @returns {string}\n   */\n  static distanceLessThan = (attribute: string, values: any[], distance: number, meters: boolean = true): string =>\n    new Query(\"distanceLessThan\", attribute, [[values, distance, meters]] as QueryTypesList).toString();\n\n  /**\n   * Filter resources where attribute intersects with the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static intersects = (attribute: string, values: any[]): string =>\n    new Query(\"intersects\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute does not intersect with the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static notIntersects = (attribute: string, values: any[]): string =>\n    new Query(\"notIntersects\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute crosses the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static crosses = (attribute: string, values: any[]): string =>\n    new Query(\"crosses\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute does not cross the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static notCrosses = (attribute: string, values: any[]): string =>\n    new Query(\"notCrosses\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute overlaps with the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static overlaps = (attribute: string, values: any[]): string =>\n    new Query(\"overlaps\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute does not overlap with the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static notOverlaps = (attribute: string, values: any[]): string =>\n    new Query(\"notOverlaps\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute touches the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static touches = (attribute: string, values: any[]): string =>\n    new Query(\"touches\", attribute, [values]).toString();\n\n  /**\n   * Filter resources where attribute does not touch the given geometry.\n   *\n   * @param {string} attribute\n   * @param {any[]} values\n   * @returns {string}\n   */\n  static notTouches = (attribute: string, values: any[]): string =>\n    new Query(\"notTouches\", attribute, [values]).toString();\n}\n"]}