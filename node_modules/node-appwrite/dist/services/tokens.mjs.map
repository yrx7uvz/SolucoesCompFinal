{"version":3,"sources":["../../src/services/tokens.ts"],"names":[],"mappings":"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","sourcesContent":["import { AppwriteException, Client, type Payload, UploadProgress } from '../client';\nimport type { Models } from '../models';\n\n\nexport class Tokens {\n    client: Client;\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n\n    /**\n     * List all the tokens created for a specific file or bucket. You can use the query params to filter your results.\n     *\n     * @param {string} params.bucketId - Storage bucket unique ID. You can create a new storage bucket using the Storage service [server integration](https://appwrite.io/docs/server/storage#createBucket).\n     * @param {string} params.fileId - File unique ID.\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: expire\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ResourceTokenList>}\n     */\n    list(params: { bucketId: string, fileId: string, queries?: string[], total?: boolean  }): Promise<Models.ResourceTokenList>;\n    /**\n     * List all the tokens created for a specific file or bucket. You can use the query params to filter your results.\n     *\n     * @param {string} bucketId - Storage bucket unique ID. You can create a new storage bucket using the Storage service [server integration](https://appwrite.io/docs/server/storage#createBucket).\n     * @param {string} fileId - File unique ID.\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: expire\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ResourceTokenList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    list(bucketId: string, fileId: string, queries?: string[], total?: boolean): Promise<Models.ResourceTokenList>;\n    list(\n        paramsOrFirst: { bucketId: string, fileId: string, queries?: string[], total?: boolean } | string,\n        ...rest: [(string)?, (string[])?, (boolean)?]    \n    ): Promise<Models.ResourceTokenList> {\n        let params: { bucketId: string, fileId: string, queries?: string[], total?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { bucketId: string, fileId: string, queries?: string[], total?: boolean };\n        } else {\n            params = {\n                bucketId: paramsOrFirst as string,\n                fileId: rest[0] as string,\n                queries: rest[1] as string[],\n                total: rest[2] as boolean            \n            };\n        }\n        \n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const queries = params.queries;\n        const total = params.total;\n\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n        const apiPath = '/tokens/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new token. A token is linked to a file. Token can be passed as a request URL search parameter.\n     *\n     * @param {string} params.bucketId - Storage bucket unique ID. You can create a new storage bucket using the Storage service [server integration](https://appwrite.io/docs/server/storage#createBucket).\n     * @param {string} params.fileId - File unique ID.\n     * @param {string} params.expire - Token expiry date\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ResourceToken>}\n     */\n    createFileToken(params: { bucketId: string, fileId: string, expire?: string  }): Promise<Models.ResourceToken>;\n    /**\n     * Create a new token. A token is linked to a file. Token can be passed as a request URL search parameter.\n     *\n     * @param {string} bucketId - Storage bucket unique ID. You can create a new storage bucket using the Storage service [server integration](https://appwrite.io/docs/server/storage#createBucket).\n     * @param {string} fileId - File unique ID.\n     * @param {string} expire - Token expiry date\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ResourceToken>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createFileToken(bucketId: string, fileId: string, expire?: string): Promise<Models.ResourceToken>;\n    createFileToken(\n        paramsOrFirst: { bucketId: string, fileId: string, expire?: string } | string,\n        ...rest: [(string)?, (string)?]    \n    ): Promise<Models.ResourceToken> {\n        let params: { bucketId: string, fileId: string, expire?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { bucketId: string, fileId: string, expire?: string };\n        } else {\n            params = {\n                bucketId: paramsOrFirst as string,\n                fileId: rest[0] as string,\n                expire: rest[1] as string            \n            };\n        }\n        \n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const expire = params.expire;\n\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n\n        const apiPath = '/tokens/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload: Payload = {};\n        if (typeof expire !== 'undefined') {\n            payload['expire'] = expire;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a token by its unique ID.\n     *\n     * @param {string} params.tokenId - Token ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ResourceToken>}\n     */\n    get(params: { tokenId: string  }): Promise<Models.ResourceToken>;\n    /**\n     * Get a token by its unique ID.\n     *\n     * @param {string} tokenId - Token ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ResourceToken>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    get(tokenId: string): Promise<Models.ResourceToken>;\n    get(\n        paramsOrFirst: { tokenId: string } | string    \n    ): Promise<Models.ResourceToken> {\n        let params: { tokenId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { tokenId: string };\n        } else {\n            params = {\n                tokenId: paramsOrFirst as string            \n            };\n        }\n        \n        const tokenId = params.tokenId;\n\n        if (typeof tokenId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tokenId\"');\n        }\n\n        const apiPath = '/tokens/{tokenId}'.replace('{tokenId}', tokenId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a token by its unique ID. Use this endpoint to update a token's expiry date.\n     *\n     * @param {string} params.tokenId - Token unique ID.\n     * @param {string} params.expire - File token expiry date\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ResourceToken>}\n     */\n    update(params: { tokenId: string, expire?: string  }): Promise<Models.ResourceToken>;\n    /**\n     * Update a token by its unique ID. Use this endpoint to update a token's expiry date.\n     *\n     * @param {string} tokenId - Token unique ID.\n     * @param {string} expire - File token expiry date\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ResourceToken>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    update(tokenId: string, expire?: string): Promise<Models.ResourceToken>;\n    update(\n        paramsOrFirst: { tokenId: string, expire?: string } | string,\n        ...rest: [(string)?]    \n    ): Promise<Models.ResourceToken> {\n        let params: { tokenId: string, expire?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { tokenId: string, expire?: string };\n        } else {\n            params = {\n                tokenId: paramsOrFirst as string,\n                expire: rest[0] as string            \n            };\n        }\n        \n        const tokenId = params.tokenId;\n        const expire = params.expire;\n\n        if (typeof tokenId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tokenId\"');\n        }\n\n        const apiPath = '/tokens/{tokenId}'.replace('{tokenId}', tokenId);\n        const payload: Payload = {};\n        if (typeof expire !== 'undefined') {\n            payload['expire'] = expire;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Delete a token by its unique ID.\n     *\n     * @param {string} params.tokenId - Token ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    delete(params: { tokenId: string  }): Promise<{}>;\n    /**\n     * Delete a token by its unique ID.\n     *\n     * @param {string} tokenId - Token ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    delete(tokenId: string): Promise<{}>;\n    delete(\n        paramsOrFirst: { tokenId: string } | string    \n    ): Promise<{}> {\n        let params: { tokenId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { tokenId: string };\n        } else {\n            params = {\n                tokenId: paramsOrFirst as string            \n            };\n        }\n        \n        const tokenId = params.tokenId;\n\n        if (typeof tokenId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tokenId\"');\n        }\n\n        const apiPath = '/tokens/{tokenId}'.replace('{tokenId}', tokenId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'delete',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n}\n"]}