import { AppwriteException } from '../client.mjs';

// src/services/functions.ts
var Functions = class {
  constructor(client) {
    this.client = client;
  }
  list(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        search: rest[0],
        total: rest[1]
      };
    }
    const queries = params.queries;
    const search = params.search;
    const total = params.total;
    const apiPath = "/functions";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    if (typeof total !== "undefined") {
      payload["total"] = total;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        name: rest[0],
        runtime: rest[1],
        execute: rest[2],
        events: rest[3],
        schedule: rest[4],
        timeout: rest[5],
        enabled: rest[6],
        logging: rest[7],
        entrypoint: rest[8],
        commands: rest[9],
        scopes: rest[10],
        installationId: rest[11],
        providerRepositoryId: rest[12],
        providerBranch: rest[13],
        providerSilentMode: rest[14],
        providerRootDirectory: rest[15],
        specification: rest[16]
      };
    }
    const functionId = params.functionId;
    const name = params.name;
    const runtime = params.runtime;
    const execute = params.execute;
    const events = params.events;
    const schedule = params.schedule;
    const timeout = params.timeout;
    const enabled = params.enabled;
    const logging = params.logging;
    const entrypoint = params.entrypoint;
    const commands = params.commands;
    const scopes = params.scopes;
    const installationId = params.installationId;
    const providerRepositoryId = params.providerRepositoryId;
    const providerBranch = params.providerBranch;
    const providerSilentMode = params.providerSilentMode;
    const providerRootDirectory = params.providerRootDirectory;
    const specification = params.specification;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    if (typeof runtime === "undefined") {
      throw new AppwriteException('Missing required parameter: "runtime"');
    }
    const apiPath = "/functions";
    const payload = {};
    if (typeof functionId !== "undefined") {
      payload["functionId"] = functionId;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof runtime !== "undefined") {
      payload["runtime"] = runtime;
    }
    if (typeof execute !== "undefined") {
      payload["execute"] = execute;
    }
    if (typeof events !== "undefined") {
      payload["events"] = events;
    }
    if (typeof schedule !== "undefined") {
      payload["schedule"] = schedule;
    }
    if (typeof timeout !== "undefined") {
      payload["timeout"] = timeout;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof logging !== "undefined") {
      payload["logging"] = logging;
    }
    if (typeof entrypoint !== "undefined") {
      payload["entrypoint"] = entrypoint;
    }
    if (typeof commands !== "undefined") {
      payload["commands"] = commands;
    }
    if (typeof scopes !== "undefined") {
      payload["scopes"] = scopes;
    }
    if (typeof installationId !== "undefined") {
      payload["installationId"] = installationId;
    }
    if (typeof providerRepositoryId !== "undefined") {
      payload["providerRepositoryId"] = providerRepositoryId;
    }
    if (typeof providerBranch !== "undefined") {
      payload["providerBranch"] = providerBranch;
    }
    if (typeof providerSilentMode !== "undefined") {
      payload["providerSilentMode"] = providerSilentMode;
    }
    if (typeof providerRootDirectory !== "undefined") {
      payload["providerRootDirectory"] = providerRootDirectory;
    }
    if (typeof specification !== "undefined") {
      payload["specification"] = specification;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get a list of all runtimes that are currently active on your instance.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.RuntimeList>}
   */
  listRuntimes() {
    const apiPath = "/functions/runtimes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List allowed function specifications for this instance.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.SpecificationList>}
   */
  listSpecifications() {
    const apiPath = "/functions/specifications";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  get(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst
      };
    }
    const functionId = params.functionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  update(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        name: rest[0],
        runtime: rest[1],
        execute: rest[2],
        events: rest[3],
        schedule: rest[4],
        timeout: rest[5],
        enabled: rest[6],
        logging: rest[7],
        entrypoint: rest[8],
        commands: rest[9],
        scopes: rest[10],
        installationId: rest[11],
        providerRepositoryId: rest[12],
        providerBranch: rest[13],
        providerSilentMode: rest[14],
        providerRootDirectory: rest[15],
        specification: rest[16]
      };
    }
    const functionId = params.functionId;
    const name = params.name;
    const runtime = params.runtime;
    const execute = params.execute;
    const events = params.events;
    const schedule = params.schedule;
    const timeout = params.timeout;
    const enabled = params.enabled;
    const logging = params.logging;
    const entrypoint = params.entrypoint;
    const commands = params.commands;
    const scopes = params.scopes;
    const installationId = params.installationId;
    const providerRepositoryId = params.providerRepositoryId;
    const providerBranch = params.providerBranch;
    const providerSilentMode = params.providerSilentMode;
    const providerRootDirectory = params.providerRootDirectory;
    const specification = params.specification;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof name === "undefined") {
      throw new AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    if (typeof runtime !== "undefined") {
      payload["runtime"] = runtime;
    }
    if (typeof execute !== "undefined") {
      payload["execute"] = execute;
    }
    if (typeof events !== "undefined") {
      payload["events"] = events;
    }
    if (typeof schedule !== "undefined") {
      payload["schedule"] = schedule;
    }
    if (typeof timeout !== "undefined") {
      payload["timeout"] = timeout;
    }
    if (typeof enabled !== "undefined") {
      payload["enabled"] = enabled;
    }
    if (typeof logging !== "undefined") {
      payload["logging"] = logging;
    }
    if (typeof entrypoint !== "undefined") {
      payload["entrypoint"] = entrypoint;
    }
    if (typeof commands !== "undefined") {
      payload["commands"] = commands;
    }
    if (typeof scopes !== "undefined") {
      payload["scopes"] = scopes;
    }
    if (typeof installationId !== "undefined") {
      payload["installationId"] = installationId;
    }
    if (typeof providerRepositoryId !== "undefined") {
      payload["providerRepositoryId"] = providerRepositoryId;
    }
    if (typeof providerBranch !== "undefined") {
      payload["providerBranch"] = providerBranch;
    }
    if (typeof providerSilentMode !== "undefined") {
      payload["providerSilentMode"] = providerSilentMode;
    }
    if (typeof providerRootDirectory !== "undefined") {
      payload["providerRootDirectory"] = providerRootDirectory;
    }
    if (typeof specification !== "undefined") {
      payload["specification"] = specification;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  delete(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst
      };
    }
    const functionId = params.functionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}".replace("{functionId}", functionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  updateFunctionDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployment".replace("{functionId}", functionId);
    const payload = {};
    if (typeof deploymentId !== "undefined") {
      payload["deploymentId"] = deploymentId;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listDeployments(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        queries: rest[0],
        search: rest[1],
        total: rest[2]
      };
    }
    const functionId = params.functionId;
    const queries = params.queries;
    const search = params.search;
    const total = params.total;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}/deployments".replace("{functionId}", functionId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof search !== "undefined") {
      payload["search"] = search;
    }
    if (typeof total !== "undefined") {
      payload["total"] = total;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createDeployment(paramsOrFirst, ...rest) {
    let params;
    let onProgress;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
      onProgress = paramsOrFirst == null ? void 0 : paramsOrFirst.onProgress;
    } else {
      params = {
        functionId: paramsOrFirst,
        code: rest[0],
        activate: rest[1],
        entrypoint: rest[2],
        commands: rest[3]
      };
      onProgress = rest[4];
    }
    const functionId = params.functionId;
    const code = params.code;
    const activate = params.activate;
    const entrypoint = params.entrypoint;
    const commands = params.commands;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof code === "undefined") {
      throw new AppwriteException('Missing required parameter: "code"');
    }
    if (typeof activate === "undefined") {
      throw new AppwriteException('Missing required parameter: "activate"');
    }
    const apiPath = "/functions/{functionId}/deployments".replace("{functionId}", functionId);
    const payload = {};
    if (typeof entrypoint !== "undefined") {
      payload["entrypoint"] = entrypoint;
    }
    if (typeof commands !== "undefined") {
      payload["commands"] = commands;
    }
    if (typeof code !== "undefined") {
      payload["code"] = code;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "multipart/form-data"
    };
    return this.client.chunkedUpload(
      "post",
      uri,
      apiHeaders,
      payload,
      onProgress
    );
  }
  createDuplicateDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0],
        buildId: rest[1]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    const buildId = params.buildId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/duplicate".replace("{functionId}", functionId);
    const payload = {};
    if (typeof deploymentId !== "undefined") {
      payload["deploymentId"] = deploymentId;
    }
    if (typeof buildId !== "undefined") {
      payload["buildId"] = buildId;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createTemplateDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        repository: rest[0],
        owner: rest[1],
        rootDirectory: rest[2],
        version: rest[3],
        activate: rest[4]
      };
    }
    const functionId = params.functionId;
    const repository = params.repository;
    const owner = params.owner;
    const rootDirectory = params.rootDirectory;
    const version = params.version;
    const activate = params.activate;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof repository === "undefined") {
      throw new AppwriteException('Missing required parameter: "repository"');
    }
    if (typeof owner === "undefined") {
      throw new AppwriteException('Missing required parameter: "owner"');
    }
    if (typeof rootDirectory === "undefined") {
      throw new AppwriteException('Missing required parameter: "rootDirectory"');
    }
    if (typeof version === "undefined") {
      throw new AppwriteException('Missing required parameter: "version"');
    }
    const apiPath = "/functions/{functionId}/deployments/template".replace("{functionId}", functionId);
    const payload = {};
    if (typeof repository !== "undefined") {
      payload["repository"] = repository;
    }
    if (typeof owner !== "undefined") {
      payload["owner"] = owner;
    }
    if (typeof rootDirectory !== "undefined") {
      payload["rootDirectory"] = rootDirectory;
    }
    if (typeof version !== "undefined") {
      payload["version"] = version;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createVcsDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        type: rest[0],
        reference: rest[1],
        activate: rest[2]
      };
    }
    const functionId = params.functionId;
    const type = params.type;
    const reference = params.reference;
    const activate = params.activate;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof type === "undefined") {
      throw new AppwriteException('Missing required parameter: "type"');
    }
    if (typeof reference === "undefined") {
      throw new AppwriteException('Missing required parameter: "reference"');
    }
    const apiPath = "/functions/{functionId}/deployments/vcs".replace("{functionId}", functionId);
    const payload = {};
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    if (typeof reference !== "undefined") {
      payload["reference"] = reference;
    }
    if (typeof activate !== "undefined") {
      payload["activate"] = activate;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteDeployment(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/{deploymentId}".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  getDeploymentDownload(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0],
        type: rest[1]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    const type = params.type;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/{deploymentId}/download".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
    const payload = {};
    if (typeof type !== "undefined") {
      payload["type"] = type;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload,
      "arrayBuffer"
    );
  }
  updateDeploymentStatus(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        deploymentId: rest[0]
      };
    }
    const functionId = params.functionId;
    const deploymentId = params.deploymentId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof deploymentId === "undefined") {
      throw new AppwriteException('Missing required parameter: "deploymentId"');
    }
    const apiPath = "/functions/{functionId}/deployments/{deploymentId}/status".replace("{functionId}", functionId).replace("{deploymentId}", deploymentId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listExecutions(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        queries: rest[0],
        total: rest[1]
      };
    }
    const functionId = params.functionId;
    const queries = params.queries;
    const total = params.total;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}/executions".replace("{functionId}", functionId);
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof total !== "undefined") {
      payload["total"] = total;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createExecution(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        body: rest[0],
        async: rest[1],
        xpath: rest[2],
        method: rest[3],
        headers: rest[4],
        scheduledAt: rest[5]
      };
    }
    const functionId = params.functionId;
    const body = params.body;
    const async = params.async;
    const xpath = params.xpath;
    const method = params.method;
    const headers = params.headers;
    const scheduledAt = params.scheduledAt;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}/executions".replace("{functionId}", functionId);
    const payload = {};
    if (typeof body !== "undefined") {
      payload["body"] = body;
    }
    if (typeof async !== "undefined") {
      payload["async"] = async;
    }
    if (typeof xpath !== "undefined") {
      payload["path"] = xpath;
    }
    if (typeof method !== "undefined") {
      payload["method"] = method;
    }
    if (typeof headers !== "undefined") {
      payload["headers"] = headers;
    }
    if (typeof scheduledAt !== "undefined") {
      payload["scheduledAt"] = scheduledAt;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getExecution(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        executionId: rest[0]
      };
    }
    const functionId = params.functionId;
    const executionId = params.executionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof executionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "executionId"');
    }
    const apiPath = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteExecution(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        executionId: rest[0]
      };
    }
    const functionId = params.functionId;
    const executionId = params.executionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof executionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "executionId"');
    }
    const apiPath = "/functions/{functionId}/executions/{executionId}".replace("{functionId}", functionId).replace("{executionId}", executionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  listVariables(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst
      };
    }
    const functionId = params.functionId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    const apiPath = "/functions/{functionId}/variables".replace("{functionId}", functionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        key: rest[0],
        value: rest[1],
        secret: rest[2]
      };
    }
    const functionId = params.functionId;
    const key = params.key;
    const value = params.value;
    const secret = params.secret;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    if (typeof value === "undefined") {
      throw new AppwriteException('Missing required parameter: "value"');
    }
    const apiPath = "/functions/{functionId}/variables".replace("{functionId}", functionId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        variableId: rest[0]
      };
    }
    const functionId = params.functionId;
    const variableId = params.variableId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        variableId: rest[0],
        key: rest[1],
        value: rest[2],
        secret: rest[3]
      };
    }
    const functionId = params.functionId;
    const variableId = params.variableId;
    const key = params.key;
    const value = params.value;
    const secret = params.secret;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    if (typeof key === "undefined") {
      throw new AppwriteException('Missing required parameter: "key"');
    }
    const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
    const payload = {};
    if (typeof key !== "undefined") {
      payload["key"] = key;
    }
    if (typeof value !== "undefined") {
      payload["value"] = value;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteVariable(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        functionId: paramsOrFirst,
        variableId: rest[0]
      };
    }
    const functionId = params.functionId;
    const variableId = params.variableId;
    if (typeof functionId === "undefined") {
      throw new AppwriteException('Missing required parameter: "functionId"');
    }
    if (typeof variableId === "undefined") {
      throw new AppwriteException('Missing required parameter: "variableId"');
    }
    const apiPath = "/functions/{functionId}/variables/{variableId}".replace("{functionId}", functionId).replace("{variableId}", variableId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
};

export { Functions };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=functions.mjs.map