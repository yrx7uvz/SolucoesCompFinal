'use strict';

var client = require('../client');

class Account {
  constructor(client) {
    this.client = client;
  }
  /**
   * Get the currently logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.User<Preferences>>}
   */
  get() {
    const apiPath = "/account";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  create(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        password: rest[1],
        name: rest[2]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const password = params.password;
    const name = params.name;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEmail(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        email: paramsOrFirst,
        password: rest[0]
      };
    }
    const email = params.email;
    const password = params.password;
    if (typeof email === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/email";
    const payload = {};
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  listIdentities(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        total: rest[0]
      };
    }
    const queries = params.queries;
    const total = params.total;
    const apiPath = "/account/identities";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof total !== "undefined") {
      payload["total"] = total;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteIdentity(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        identityId: paramsOrFirst
      };
    }
    const identityId = params.identityId;
    if (typeof identityId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "identityId"');
    }
    const apiPath = "/account/identities/{identityId}".replace("{identityId}", identityId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Use this endpoint to create a JSON Web Token. You can use the resulting JWT to authenticate on behalf of the current user when working with the Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes from its creation and will be invalid if the user will logout in that time frame.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.Jwt>}
   */
  createJWT() {
    const apiPath = "/account/jwts";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  listLogs(paramsOrFirst, ...rest) {
    let params;
    if (!paramsOrFirst || paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        queries: paramsOrFirst,
        total: rest[0]
      };
    }
    const queries = params.queries;
    const total = params.total;
    const apiPath = "/account/logs";
    const payload = {};
    if (typeof queries !== "undefined") {
      payload["queries"] = queries;
    }
    if (typeof total !== "undefined") {
      payload["total"] = total;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMFA(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        mfa: paramsOrFirst
      };
    }
    const mfa = params.mfa;
    if (typeof mfa === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "mfa"');
    }
    const apiPath = "/account/mfa";
    const payload = {};
    if (typeof mfa !== "undefined") {
      payload["mfa"] = mfa;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createMfaAuthenticator(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst
      };
    }
    const type = params.type;
    if (typeof type === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createMFAAuthenticator(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst
      };
    }
    const type = params.type;
    if (typeof type === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMfaAuthenticator(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst,
        otp: rest[0]
      };
    }
    const type = params.type;
    const otp = params.otp;
    if (typeof type === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "type"');
    }
    if (typeof otp === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "otp"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    if (typeof otp !== "undefined") {
      payload["otp"] = otp;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMFAAuthenticator(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst,
        otp: rest[0]
      };
    }
    const type = params.type;
    const otp = params.otp;
    if (typeof type === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "type"');
    }
    if (typeof otp === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "otp"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    if (typeof otp !== "undefined") {
      payload["otp"] = otp;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteMfaAuthenticator(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst
      };
    }
    const type = params.type;
    if (typeof type === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteMFAAuthenticator(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "type" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        type: paramsOrFirst
      };
    }
    const type = params.type;
    if (typeof type === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "type"');
    }
    const apiPath = "/account/mfa/authenticators/{type}".replace("{type}", type);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  createMfaChallenge(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "factor" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        factor: paramsOrFirst
      };
    }
    const factor = params.factor;
    if (typeof factor === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "factor"');
    }
    const apiPath = "/account/mfa/challenge";
    const payload = {};
    if (typeof factor !== "undefined") {
      payload["factor"] = factor;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createMFAChallenge(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "factor" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        factor: paramsOrFirst
      };
    }
    const factor = params.factor;
    if (typeof factor === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "factor"');
    }
    const apiPath = "/account/mfa/challenge";
    const payload = {};
    if (typeof factor !== "undefined") {
      payload["factor"] = factor;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMfaChallenge(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        challengeId: paramsOrFirst,
        otp: rest[0]
      };
    }
    const challengeId = params.challengeId;
    const otp = params.otp;
    if (typeof challengeId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "challengeId"');
    }
    if (typeof otp === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "otp"');
    }
    const apiPath = "/account/mfa/challenge";
    const payload = {};
    if (typeof challengeId !== "undefined") {
      payload["challengeId"] = challengeId;
    }
    if (typeof otp !== "undefined") {
      payload["otp"] = otp;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMFAChallenge(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        challengeId: paramsOrFirst,
        otp: rest[0]
      };
    }
    const challengeId = params.challengeId;
    const otp = params.otp;
    if (typeof challengeId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "challengeId"');
    }
    if (typeof otp === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "otp"');
    }
    const apiPath = "/account/mfa/challenge";
    const payload = {};
    if (typeof challengeId !== "undefined") {
      payload["challengeId"] = challengeId;
    }
    if (typeof otp !== "undefined") {
      payload["otp"] = otp;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List the factors available on the account to be used as a MFA challange.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaFactors>}
   * @deprecated This API has been deprecated since 1.8.0. Please use `Account.listMFAFactors` instead.
   */
  listMfaFactors() {
    const apiPath = "/account/mfa/factors";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * List the factors available on the account to be used as a MFA challange.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaFactors>}
   */
  listMFAFactors() {
    const apiPath = "/account/mfa/factors";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   * @deprecated This API has been deprecated since 1.8.0. Please use `Account.getMFARecoveryCodes` instead.
   */
  getMfaRecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   */
  getMFARecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   * @deprecated This API has been deprecated since 1.8.0. Please use `Account.createMFARecoveryCodes` instead.
   */
  createMfaRecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   */
  createMFARecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   * @deprecated This API has been deprecated since 1.8.0. Please use `Account.updateMFARecoveryCodes` instead.
   */
  updateMfaRecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.MfaRecoveryCodes>}
   */
  updateMFARecoveryCodes() {
    const apiPath = "/account/mfa/recovery-codes";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updateName(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        name: paramsOrFirst
      };
    }
    const name = params.name;
    if (typeof name === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "name"');
    }
    const apiPath = "/account/name";
    const payload = {};
    if (typeof name !== "undefined") {
      payload["name"] = name;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePassword(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        password: paramsOrFirst,
        oldPassword: rest[0]
      };
    }
    const password = params.password;
    const oldPassword = params.oldPassword;
    if (typeof password === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/password";
    const payload = {};
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    if (typeof oldPassword !== "undefined") {
      payload["oldPassword"] = oldPassword;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePhone(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        phone: paramsOrFirst,
        password: rest[0]
      };
    }
    const phone = params.phone;
    const password = params.password;
    if (typeof phone === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "phone"');
    }
    if (typeof password === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/phone";
    const payload = {};
    if (typeof phone !== "undefined") {
      payload["phone"] = phone;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get the preferences as a key-value object for the currently logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Preferences>}
   */
  getPrefs() {
    const apiPath = "/account/prefs";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePrefs(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "prefs" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        prefs: paramsOrFirst
      };
    }
    const prefs = params.prefs;
    if (typeof prefs === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "prefs"');
    }
    const apiPath = "/account/prefs";
    const payload = {};
    if (typeof prefs !== "undefined") {
      payload["prefs"] = prefs;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createRecovery(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        email: paramsOrFirst,
        url: rest[0]
      };
    }
    const email = params.email;
    const url = params.url;
    if (typeof email === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "email"');
    }
    if (typeof url === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "url"');
    }
    const apiPath = "/account/recovery";
    const payload = {};
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateRecovery(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0],
        password: rest[1]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    const password = params.password;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "secret"');
    }
    if (typeof password === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/recovery";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Get the list of active sessions across different devices for the currently logged in user.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.SessionList>}
   */
  listSessions() {
    const apiPath = "/account/sessions";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Delete all sessions from the user account and remove any sessions cookies from the end client.
   *
   * @throws {AppwriteException}
   * @returns {Promise<{}>}
   */
  deleteSessions() {
    const apiPath = "/account/sessions";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Use this endpoint to allow a new user to register an anonymous account in your project. This route will also create a new session for the user. To allow the new user to convert an anonymous account to a normal account, you need to update its [email and password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail) or create an [OAuth2 session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.Session>}
   */
  createAnonymousSession() {
    const apiPath = "/account/sessions/anonymous";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createEmailPasswordSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        email: paramsOrFirst,
        password: rest[0]
      };
    }
    const email = params.email;
    const password = params.password;
    if (typeof email === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "email"');
    }
    if (typeof password === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "password"');
    }
    const apiPath = "/account/sessions/email";
    const payload = {};
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof password !== "undefined") {
      payload["password"] = password;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateMagicURLSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/sessions/magic-url";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePhoneSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/sessions/phone";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  createSession(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/sessions/token";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  getSession(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        sessionId: paramsOrFirst
      };
    }
    const sessionId = params.sessionId;
    if (typeof sessionId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "sessionId"');
    }
    const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.call(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  updateSession(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        sessionId: paramsOrFirst
      };
    }
    const sessionId = params.sessionId;
    if (typeof sessionId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "sessionId"');
    }
    const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  deleteSession(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        sessionId: paramsOrFirst
      };
    }
    const sessionId = params.sessionId;
    if (typeof sessionId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "sessionId"');
    }
    const apiPath = "/account/sessions/{sessionId}".replace("{sessionId}", sessionId);
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "delete",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Block the currently logged in user account. Behind the scene, the user record is not deleted but permanently blocked from any access. To completely delete a user, use the Users API instead.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.User<Preferences>>}
   */
  updateStatus() {
    const apiPath = "/account/status";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "patch",
      uri,
      apiHeaders,
      payload
    );
  }
  createEmailToken(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        phrase: rest[1]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const phrase = params.phrase;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "email"');
    }
    const apiPath = "/account/tokens/email";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof phrase !== "undefined") {
      payload["phrase"] = phrase;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createMagicURLToken(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        email: rest[0],
        url: rest[1],
        phrase: rest[2]
      };
    }
    const userId = params.userId;
    const email = params.email;
    const url = params.url;
    const phrase = params.phrase;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof email === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "email"');
    }
    const apiPath = "/account/tokens/magic-url";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof email !== "undefined") {
      payload["email"] = email;
    }
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    if (typeof phrase !== "undefined") {
      payload["phrase"] = phrase;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createOAuth2Token(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst) && "provider" in paramsOrFirst) {
      params = paramsOrFirst || {};
    } else {
      params = {
        provider: paramsOrFirst,
        success: rest[0],
        failure: rest[1],
        scopes: rest[2]
      };
    }
    const provider = params.provider;
    const success = params.success;
    const failure = params.failure;
    const scopes = params.scopes;
    if (typeof provider === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "provider"');
    }
    const apiPath = "/account/tokens/oauth2/{provider}".replace("{provider}", provider);
    const payload = {};
    if (typeof success !== "undefined") {
      payload["success"] = success;
    }
    if (typeof failure !== "undefined") {
      payload["failure"] = failure;
    }
    if (typeof scopes !== "undefined") {
      payload["scopes"] = scopes;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {};
    return this.client.redirect(
      "get",
      uri,
      apiHeaders,
      payload
    );
  }
  createPhoneToken(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        phone: rest[0]
      };
    }
    const userId = params.userId;
    const phone = params.phone;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof phone === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "phone"');
    }
    const apiPath = "/account/tokens/phone";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof phone !== "undefined") {
      payload["phone"] = phone;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createEmailVerification(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        url: paramsOrFirst
      };
    }
    const url = params.url;
    if (typeof url === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "url"');
    }
    const apiPath = "/account/verifications/email";
    const payload = {};
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  createVerification(paramsOrFirst) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        url: paramsOrFirst
      };
    }
    const url = params.url;
    if (typeof url === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "url"');
    }
    const apiPath = "/account/verifications/email";
    const payload = {};
    if (typeof url !== "undefined") {
      payload["url"] = url;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updateEmailVerification(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/verifications/email";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  updateVerification(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/verifications/email";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
  /**
   * Use this endpoint to send a verification SMS to the currently logged in user. This endpoint is meant for use after updating a user's phone number using the [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone) endpoint. Learn more about how to [complete the verification process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification). The verification code sent to the user's phone number is valid for 15 minutes.
   *
   * @throws {AppwriteException}
   * @returns {Promise<Models.Token>}
   */
  createPhoneVerification() {
    const apiPath = "/account/verifications/phone";
    const payload = {};
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "post",
      uri,
      apiHeaders,
      payload
    );
  }
  updatePhoneVerification(paramsOrFirst, ...rest) {
    let params;
    if (paramsOrFirst && typeof paramsOrFirst === "object" && !Array.isArray(paramsOrFirst)) {
      params = paramsOrFirst || {};
    } else {
      params = {
        userId: paramsOrFirst,
        secret: rest[0]
      };
    }
    const userId = params.userId;
    const secret = params.secret;
    if (typeof userId === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "userId"');
    }
    if (typeof secret === "undefined") {
      throw new client.AppwriteException('Missing required parameter: "secret"');
    }
    const apiPath = "/account/verifications/phone";
    const payload = {};
    if (typeof userId !== "undefined") {
      payload["userId"] = userId;
    }
    if (typeof secret !== "undefined") {
      payload["secret"] = secret;
    }
    const uri = new URL(this.client.config.endpoint + apiPath);
    const apiHeaders = {
      "content-type": "application/json"
    };
    return this.client.call(
      "put",
      uri,
      apiHeaders,
      payload
    );
  }
}

exports.Account = Account;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=account.js.map