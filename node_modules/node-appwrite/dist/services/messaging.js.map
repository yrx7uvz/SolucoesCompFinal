{"version":3,"sources":["../../src/services/messaging.ts"],"names":[],"mappings":"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","sourcesContent":["import { AppwriteException, Client, type Payload, UploadProgress } from '../client';\nimport type { Models } from '../models';\n\nimport { MessagePriority } from '../enums/message-priority';\nimport { SmtpEncryption } from '../enums/smtp-encryption';\n\nexport class Messaging {\n    client: Client;\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n\n    /**\n     * Get a list of all messages from the current Appwrite project.\n     *\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: scheduledAt, deliveredAt, deliveredTotal, status, description, providerType\n     * @param {string} params.search - Search term to filter your list results. Max length: 256 chars.\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MessageList>}\n     */\n    listMessages(params?: { queries?: string[], search?: string, total?: boolean  }): Promise<Models.MessageList>;\n    /**\n     * Get a list of all messages from the current Appwrite project.\n     *\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: scheduledAt, deliveredAt, deliveredTotal, status, description, providerType\n     * @param {string} search - Search term to filter your list results. Max length: 256 chars.\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MessageList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listMessages(queries?: string[], search?: string, total?: boolean): Promise<Models.MessageList>;\n    listMessages(\n        paramsOrFirst?: { queries?: string[], search?: string, total?: boolean } | string[],\n        ...rest: [(string)?, (boolean)?]    \n    ): Promise<Models.MessageList> {\n        let params: { queries?: string[], search?: string, total?: boolean };\n        \n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { queries?: string[], search?: string, total?: boolean };\n        } else {\n            params = {\n                queries: paramsOrFirst as string[],\n                search: rest[0] as string,\n                total: rest[1] as boolean            \n            };\n        }\n        \n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n\n\n        const apiPath = '/messaging/messages';\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new email message.\n     *\n     * @param {string} params.messageId - Message ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.subject - Email Subject.\n     * @param {string} params.content - Email Content.\n     * @param {string[]} params.topics - List of Topic IDs.\n     * @param {string[]} params.users - List of User IDs.\n     * @param {string[]} params.targets - List of Targets IDs.\n     * @param {string[]} params.cc - Array of target IDs to be added as CC.\n     * @param {string[]} params.bcc - Array of target IDs to be added as BCC.\n     * @param {string[]} params.attachments - Array of compound ID strings of bucket IDs and file IDs to be attached to the email. They should be formatted as <BUCKET_ID>:<FILE_ID>.\n     * @param {boolean} params.draft - Is message a draft\n     * @param {boolean} params.html - Is content of type HTML\n     * @param {string} params.scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     */\n    createEmail(params: { messageId: string, subject: string, content: string, topics?: string[], users?: string[], targets?: string[], cc?: string[], bcc?: string[], attachments?: string[], draft?: boolean, html?: boolean, scheduledAt?: string  }): Promise<Models.Message>;\n    /**\n     * Create a new email message.\n     *\n     * @param {string} messageId - Message ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} subject - Email Subject.\n     * @param {string} content - Email Content.\n     * @param {string[]} topics - List of Topic IDs.\n     * @param {string[]} users - List of User IDs.\n     * @param {string[]} targets - List of Targets IDs.\n     * @param {string[]} cc - Array of target IDs to be added as CC.\n     * @param {string[]} bcc - Array of target IDs to be added as BCC.\n     * @param {string[]} attachments - Array of compound ID strings of bucket IDs and file IDs to be attached to the email. They should be formatted as <BUCKET_ID>:<FILE_ID>.\n     * @param {boolean} draft - Is message a draft\n     * @param {boolean} html - Is content of type HTML\n     * @param {string} scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createEmail(messageId: string, subject: string, content: string, topics?: string[], users?: string[], targets?: string[], cc?: string[], bcc?: string[], attachments?: string[], draft?: boolean, html?: boolean, scheduledAt?: string): Promise<Models.Message>;\n    createEmail(\n        paramsOrFirst: { messageId: string, subject: string, content: string, topics?: string[], users?: string[], targets?: string[], cc?: string[], bcc?: string[], attachments?: string[], draft?: boolean, html?: boolean, scheduledAt?: string } | string,\n        ...rest: [(string)?, (string)?, (string[])?, (string[])?, (string[])?, (string[])?, (string[])?, (string[])?, (boolean)?, (boolean)?, (string)?]    \n    ): Promise<Models.Message> {\n        let params: { messageId: string, subject: string, content: string, topics?: string[], users?: string[], targets?: string[], cc?: string[], bcc?: string[], attachments?: string[], draft?: boolean, html?: boolean, scheduledAt?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, subject: string, content: string, topics?: string[], users?: string[], targets?: string[], cc?: string[], bcc?: string[], attachments?: string[], draft?: boolean, html?: boolean, scheduledAt?: string };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                subject: rest[0] as string,\n                content: rest[1] as string,\n                topics: rest[2] as string[],\n                users: rest[3] as string[],\n                targets: rest[4] as string[],\n                cc: rest[5] as string[],\n                bcc: rest[6] as string[],\n                attachments: rest[7] as string[],\n                draft: rest[8] as boolean,\n                html: rest[9] as boolean,\n                scheduledAt: rest[10] as string            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const subject = params.subject;\n        const content = params.content;\n        const topics = params.topics;\n        const users = params.users;\n        const targets = params.targets;\n        const cc = params.cc;\n        const bcc = params.bcc;\n        const attachments = params.attachments;\n        const draft = params.draft;\n        const html = params.html;\n        const scheduledAt = params.scheduledAt;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n        if (typeof subject === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subject\"');\n        }\n        if (typeof content === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"content\"');\n        }\n\n        const apiPath = '/messaging/messages/email';\n        const payload: Payload = {};\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n        if (typeof subject !== 'undefined') {\n            payload['subject'] = subject;\n        }\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n        if (typeof cc !== 'undefined') {\n            payload['cc'] = cc;\n        }\n        if (typeof bcc !== 'undefined') {\n            payload['bcc'] = bcc;\n        }\n        if (typeof attachments !== 'undefined') {\n            payload['attachments'] = attachments;\n        }\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n        if (typeof html !== 'undefined') {\n            payload['html'] = html;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update an email message by its unique ID. This endpoint only works on messages that are in draft status. Messages that are already processing, sent, or failed cannot be updated.\n     * \n     *\n     * @param {string} params.messageId - Message ID.\n     * @param {string[]} params.topics - List of Topic IDs.\n     * @param {string[]} params.users - List of User IDs.\n     * @param {string[]} params.targets - List of Targets IDs.\n     * @param {string} params.subject - Email Subject.\n     * @param {string} params.content - Email Content.\n     * @param {boolean} params.draft - Is message a draft\n     * @param {boolean} params.html - Is content of type HTML\n     * @param {string[]} params.cc - Array of target IDs to be added as CC.\n     * @param {string[]} params.bcc - Array of target IDs to be added as BCC.\n     * @param {string} params.scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @param {string[]} params.attachments - Array of compound ID strings of bucket IDs and file IDs to be attached to the email. They should be formatted as <BUCKET_ID>:<FILE_ID>.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     */\n    updateEmail(params: { messageId: string, topics?: string[], users?: string[], targets?: string[], subject?: string, content?: string, draft?: boolean, html?: boolean, cc?: string[], bcc?: string[], scheduledAt?: string, attachments?: string[]  }): Promise<Models.Message>;\n    /**\n     * Update an email message by its unique ID. This endpoint only works on messages that are in draft status. Messages that are already processing, sent, or failed cannot be updated.\n     * \n     *\n     * @param {string} messageId - Message ID.\n     * @param {string[]} topics - List of Topic IDs.\n     * @param {string[]} users - List of User IDs.\n     * @param {string[]} targets - List of Targets IDs.\n     * @param {string} subject - Email Subject.\n     * @param {string} content - Email Content.\n     * @param {boolean} draft - Is message a draft\n     * @param {boolean} html - Is content of type HTML\n     * @param {string[]} cc - Array of target IDs to be added as CC.\n     * @param {string[]} bcc - Array of target IDs to be added as BCC.\n     * @param {string} scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @param {string[]} attachments - Array of compound ID strings of bucket IDs and file IDs to be attached to the email. They should be formatted as <BUCKET_ID>:<FILE_ID>.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateEmail(messageId: string, topics?: string[], users?: string[], targets?: string[], subject?: string, content?: string, draft?: boolean, html?: boolean, cc?: string[], bcc?: string[], scheduledAt?: string, attachments?: string[]): Promise<Models.Message>;\n    updateEmail(\n        paramsOrFirst: { messageId: string, topics?: string[], users?: string[], targets?: string[], subject?: string, content?: string, draft?: boolean, html?: boolean, cc?: string[], bcc?: string[], scheduledAt?: string, attachments?: string[] } | string,\n        ...rest: [(string[])?, (string[])?, (string[])?, (string)?, (string)?, (boolean)?, (boolean)?, (string[])?, (string[])?, (string)?, (string[])?]    \n    ): Promise<Models.Message> {\n        let params: { messageId: string, topics?: string[], users?: string[], targets?: string[], subject?: string, content?: string, draft?: boolean, html?: boolean, cc?: string[], bcc?: string[], scheduledAt?: string, attachments?: string[] };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, topics?: string[], users?: string[], targets?: string[], subject?: string, content?: string, draft?: boolean, html?: boolean, cc?: string[], bcc?: string[], scheduledAt?: string, attachments?: string[] };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                topics: rest[0] as string[],\n                users: rest[1] as string[],\n                targets: rest[2] as string[],\n                subject: rest[3] as string,\n                content: rest[4] as string,\n                draft: rest[5] as boolean,\n                html: rest[6] as boolean,\n                cc: rest[7] as string[],\n                bcc: rest[8] as string[],\n                scheduledAt: rest[9] as string,\n                attachments: rest[10] as string[]            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const topics = params.topics;\n        const users = params.users;\n        const targets = params.targets;\n        const subject = params.subject;\n        const content = params.content;\n        const draft = params.draft;\n        const html = params.html;\n        const cc = params.cc;\n        const bcc = params.bcc;\n        const scheduledAt = params.scheduledAt;\n        const attachments = params.attachments;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/email/{messageId}'.replace('{messageId}', messageId);\n        const payload: Payload = {};\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n        if (typeof subject !== 'undefined') {\n            payload['subject'] = subject;\n        }\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n        if (typeof html !== 'undefined') {\n            payload['html'] = html;\n        }\n        if (typeof cc !== 'undefined') {\n            payload['cc'] = cc;\n        }\n        if (typeof bcc !== 'undefined') {\n            payload['bcc'] = bcc;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        if (typeof attachments !== 'undefined') {\n            payload['attachments'] = attachments;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new push notification.\n     *\n     * @param {string} params.messageId - Message ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.title - Title for push notification.\n     * @param {string} params.body - Body for push notification.\n     * @param {string[]} params.topics - List of Topic IDs.\n     * @param {string[]} params.users - List of User IDs.\n     * @param {string[]} params.targets - List of Targets IDs.\n     * @param {object} params.data - Additional key-value pair data for push notification.\n     * @param {string} params.action - Action for push notification.\n     * @param {string} params.image - Image for push notification. Must be a compound bucket ID to file ID of a jpeg, png, or bmp image in Appwrite Storage. It should be formatted as <BUCKET_ID>:<FILE_ID>.\n     * @param {string} params.icon - Icon for push notification. Available only for Android and Web Platform.\n     * @param {string} params.sound - Sound for push notification. Available only for Android and iOS Platform.\n     * @param {string} params.color - Color for push notification. Available only for Android Platform.\n     * @param {string} params.tag - Tag for push notification. Available only for Android Platform.\n     * @param {number} params.badge - Badge for push notification. Available only for iOS Platform.\n     * @param {boolean} params.draft - Is message a draft\n     * @param {string} params.scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @param {boolean} params.contentAvailable - If set to true, the notification will be delivered in the background. Available only for iOS Platform.\n     * @param {boolean} params.critical - If set to true, the notification will be marked as critical. This requires the app to have the critical notification entitlement. Available only for iOS Platform.\n     * @param {MessagePriority} params.priority - Set the notification priority. \"normal\" will consider device state and may not deliver notifications immediately. \"high\" will always attempt to immediately deliver the notification.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     */\n    createPush(params: { messageId: string, title?: string, body?: string, topics?: string[], users?: string[], targets?: string[], data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority  }): Promise<Models.Message>;\n    /**\n     * Create a new push notification.\n     *\n     * @param {string} messageId - Message ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} title - Title for push notification.\n     * @param {string} body - Body for push notification.\n     * @param {string[]} topics - List of Topic IDs.\n     * @param {string[]} users - List of User IDs.\n     * @param {string[]} targets - List of Targets IDs.\n     * @param {object} data - Additional key-value pair data for push notification.\n     * @param {string} action - Action for push notification.\n     * @param {string} image - Image for push notification. Must be a compound bucket ID to file ID of a jpeg, png, or bmp image in Appwrite Storage. It should be formatted as <BUCKET_ID>:<FILE_ID>.\n     * @param {string} icon - Icon for push notification. Available only for Android and Web Platform.\n     * @param {string} sound - Sound for push notification. Available only for Android and iOS Platform.\n     * @param {string} color - Color for push notification. Available only for Android Platform.\n     * @param {string} tag - Tag for push notification. Available only for Android Platform.\n     * @param {number} badge - Badge for push notification. Available only for iOS Platform.\n     * @param {boolean} draft - Is message a draft\n     * @param {string} scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @param {boolean} contentAvailable - If set to true, the notification will be delivered in the background. Available only for iOS Platform.\n     * @param {boolean} critical - If set to true, the notification will be marked as critical. This requires the app to have the critical notification entitlement. Available only for iOS Platform.\n     * @param {MessagePriority} priority - Set the notification priority. \"normal\" will consider device state and may not deliver notifications immediately. \"high\" will always attempt to immediately deliver the notification.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createPush(messageId: string, title?: string, body?: string, topics?: string[], users?: string[], targets?: string[], data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority): Promise<Models.Message>;\n    createPush(\n        paramsOrFirst: { messageId: string, title?: string, body?: string, topics?: string[], users?: string[], targets?: string[], data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority } | string,\n        ...rest: [(string)?, (string)?, (string[])?, (string[])?, (string[])?, (object)?, (string)?, (string)?, (string)?, (string)?, (string)?, (string)?, (number)?, (boolean)?, (string)?, (boolean)?, (boolean)?, (MessagePriority)?]    \n    ): Promise<Models.Message> {\n        let params: { messageId: string, title?: string, body?: string, topics?: string[], users?: string[], targets?: string[], data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, title?: string, body?: string, topics?: string[], users?: string[], targets?: string[], data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                title: rest[0] as string,\n                body: rest[1] as string,\n                topics: rest[2] as string[],\n                users: rest[3] as string[],\n                targets: rest[4] as string[],\n                data: rest[5] as object,\n                action: rest[6] as string,\n                image: rest[7] as string,\n                icon: rest[8] as string,\n                sound: rest[9] as string,\n                color: rest[10] as string,\n                tag: rest[11] as string,\n                badge: rest[12] as number,\n                draft: rest[13] as boolean,\n                scheduledAt: rest[14] as string,\n                contentAvailable: rest[15] as boolean,\n                critical: rest[16] as boolean,\n                priority: rest[17] as MessagePriority            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const title = params.title;\n        const body = params.body;\n        const topics = params.topics;\n        const users = params.users;\n        const targets = params.targets;\n        const data = params.data;\n        const action = params.action;\n        const image = params.image;\n        const icon = params.icon;\n        const sound = params.sound;\n        const color = params.color;\n        const tag = params.tag;\n        const badge = params.badge;\n        const draft = params.draft;\n        const scheduledAt = params.scheduledAt;\n        const contentAvailable = params.contentAvailable;\n        const critical = params.critical;\n        const priority = params.priority;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/push';\n        const payload: Payload = {};\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n        if (typeof title !== 'undefined') {\n            payload['title'] = title;\n        }\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof action !== 'undefined') {\n            payload['action'] = action;\n        }\n        if (typeof image !== 'undefined') {\n            payload['image'] = image;\n        }\n        if (typeof icon !== 'undefined') {\n            payload['icon'] = icon;\n        }\n        if (typeof sound !== 'undefined') {\n            payload['sound'] = sound;\n        }\n        if (typeof color !== 'undefined') {\n            payload['color'] = color;\n        }\n        if (typeof tag !== 'undefined') {\n            payload['tag'] = tag;\n        }\n        if (typeof badge !== 'undefined') {\n            payload['badge'] = badge;\n        }\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        if (typeof contentAvailable !== 'undefined') {\n            payload['contentAvailable'] = contentAvailable;\n        }\n        if (typeof critical !== 'undefined') {\n            payload['critical'] = critical;\n        }\n        if (typeof priority !== 'undefined') {\n            payload['priority'] = priority;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a push notification by its unique ID. This endpoint only works on messages that are in draft status. Messages that are already processing, sent, or failed cannot be updated.\n     * \n     *\n     * @param {string} params.messageId - Message ID.\n     * @param {string[]} params.topics - List of Topic IDs.\n     * @param {string[]} params.users - List of User IDs.\n     * @param {string[]} params.targets - List of Targets IDs.\n     * @param {string} params.title - Title for push notification.\n     * @param {string} params.body - Body for push notification.\n     * @param {object} params.data - Additional Data for push notification.\n     * @param {string} params.action - Action for push notification.\n     * @param {string} params.image - Image for push notification. Must be a compound bucket ID to file ID of a jpeg, png, or bmp image in Appwrite Storage. It should be formatted as <BUCKET_ID>:<FILE_ID>.\n     * @param {string} params.icon - Icon for push notification. Available only for Android and Web platforms.\n     * @param {string} params.sound - Sound for push notification. Available only for Android and iOS platforms.\n     * @param {string} params.color - Color for push notification. Available only for Android platforms.\n     * @param {string} params.tag - Tag for push notification. Available only for Android platforms.\n     * @param {number} params.badge - Badge for push notification. Available only for iOS platforms.\n     * @param {boolean} params.draft - Is message a draft\n     * @param {string} params.scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @param {boolean} params.contentAvailable - If set to true, the notification will be delivered in the background. Available only for iOS Platform.\n     * @param {boolean} params.critical - If set to true, the notification will be marked as critical. This requires the app to have the critical notification entitlement. Available only for iOS Platform.\n     * @param {MessagePriority} params.priority - Set the notification priority. \"normal\" will consider device battery state and may send notifications later. \"high\" will always attempt to immediately deliver the notification.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     */\n    updatePush(params: { messageId: string, topics?: string[], users?: string[], targets?: string[], title?: string, body?: string, data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority  }): Promise<Models.Message>;\n    /**\n     * Update a push notification by its unique ID. This endpoint only works on messages that are in draft status. Messages that are already processing, sent, or failed cannot be updated.\n     * \n     *\n     * @param {string} messageId - Message ID.\n     * @param {string[]} topics - List of Topic IDs.\n     * @param {string[]} users - List of User IDs.\n     * @param {string[]} targets - List of Targets IDs.\n     * @param {string} title - Title for push notification.\n     * @param {string} body - Body for push notification.\n     * @param {object} data - Additional Data for push notification.\n     * @param {string} action - Action for push notification.\n     * @param {string} image - Image for push notification. Must be a compound bucket ID to file ID of a jpeg, png, or bmp image in Appwrite Storage. It should be formatted as <BUCKET_ID>:<FILE_ID>.\n     * @param {string} icon - Icon for push notification. Available only for Android and Web platforms.\n     * @param {string} sound - Sound for push notification. Available only for Android and iOS platforms.\n     * @param {string} color - Color for push notification. Available only for Android platforms.\n     * @param {string} tag - Tag for push notification. Available only for Android platforms.\n     * @param {number} badge - Badge for push notification. Available only for iOS platforms.\n     * @param {boolean} draft - Is message a draft\n     * @param {string} scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @param {boolean} contentAvailable - If set to true, the notification will be delivered in the background. Available only for iOS Platform.\n     * @param {boolean} critical - If set to true, the notification will be marked as critical. This requires the app to have the critical notification entitlement. Available only for iOS Platform.\n     * @param {MessagePriority} priority - Set the notification priority. \"normal\" will consider device battery state and may send notifications later. \"high\" will always attempt to immediately deliver the notification.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updatePush(messageId: string, topics?: string[], users?: string[], targets?: string[], title?: string, body?: string, data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority): Promise<Models.Message>;\n    updatePush(\n        paramsOrFirst: { messageId: string, topics?: string[], users?: string[], targets?: string[], title?: string, body?: string, data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority } | string,\n        ...rest: [(string[])?, (string[])?, (string[])?, (string)?, (string)?, (object)?, (string)?, (string)?, (string)?, (string)?, (string)?, (string)?, (number)?, (boolean)?, (string)?, (boolean)?, (boolean)?, (MessagePriority)?]    \n    ): Promise<Models.Message> {\n        let params: { messageId: string, topics?: string[], users?: string[], targets?: string[], title?: string, body?: string, data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, topics?: string[], users?: string[], targets?: string[], title?: string, body?: string, data?: object, action?: string, image?: string, icon?: string, sound?: string, color?: string, tag?: string, badge?: number, draft?: boolean, scheduledAt?: string, contentAvailable?: boolean, critical?: boolean, priority?: MessagePriority };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                topics: rest[0] as string[],\n                users: rest[1] as string[],\n                targets: rest[2] as string[],\n                title: rest[3] as string,\n                body: rest[4] as string,\n                data: rest[5] as object,\n                action: rest[6] as string,\n                image: rest[7] as string,\n                icon: rest[8] as string,\n                sound: rest[9] as string,\n                color: rest[10] as string,\n                tag: rest[11] as string,\n                badge: rest[12] as number,\n                draft: rest[13] as boolean,\n                scheduledAt: rest[14] as string,\n                contentAvailable: rest[15] as boolean,\n                critical: rest[16] as boolean,\n                priority: rest[17] as MessagePriority            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const topics = params.topics;\n        const users = params.users;\n        const targets = params.targets;\n        const title = params.title;\n        const body = params.body;\n        const data = params.data;\n        const action = params.action;\n        const image = params.image;\n        const icon = params.icon;\n        const sound = params.sound;\n        const color = params.color;\n        const tag = params.tag;\n        const badge = params.badge;\n        const draft = params.draft;\n        const scheduledAt = params.scheduledAt;\n        const contentAvailable = params.contentAvailable;\n        const critical = params.critical;\n        const priority = params.priority;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/push/{messageId}'.replace('{messageId}', messageId);\n        const payload: Payload = {};\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n        if (typeof title !== 'undefined') {\n            payload['title'] = title;\n        }\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof action !== 'undefined') {\n            payload['action'] = action;\n        }\n        if (typeof image !== 'undefined') {\n            payload['image'] = image;\n        }\n        if (typeof icon !== 'undefined') {\n            payload['icon'] = icon;\n        }\n        if (typeof sound !== 'undefined') {\n            payload['sound'] = sound;\n        }\n        if (typeof color !== 'undefined') {\n            payload['color'] = color;\n        }\n        if (typeof tag !== 'undefined') {\n            payload['tag'] = tag;\n        }\n        if (typeof badge !== 'undefined') {\n            payload['badge'] = badge;\n        }\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        if (typeof contentAvailable !== 'undefined') {\n            payload['contentAvailable'] = contentAvailable;\n        }\n        if (typeof critical !== 'undefined') {\n            payload['critical'] = critical;\n        }\n        if (typeof priority !== 'undefined') {\n            payload['priority'] = priority;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new SMS message.\n     *\n     * @param {string} params.messageId - Message ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.content - SMS Content.\n     * @param {string[]} params.topics - List of Topic IDs.\n     * @param {string[]} params.users - List of User IDs.\n     * @param {string[]} params.targets - List of Targets IDs.\n     * @param {boolean} params.draft - Is message a draft\n     * @param {string} params.scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Messaging.createSMS` instead.\n     */\n    createSms(params: { messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string  }): Promise<Models.Message>;\n    /**\n     * Create a new SMS message.\n     *\n     * @param {string} messageId - Message ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} content - SMS Content.\n     * @param {string[]} topics - List of Topic IDs.\n     * @param {string[]} users - List of User IDs.\n     * @param {string[]} targets - List of Targets IDs.\n     * @param {boolean} draft - Is message a draft\n     * @param {string} scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createSms(messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string): Promise<Models.Message>;\n    createSms(\n        paramsOrFirst: { messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string } | string,\n        ...rest: [(string)?, (string[])?, (string[])?, (string[])?, (boolean)?, (string)?]    \n    ): Promise<Models.Message> {\n        let params: { messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                content: rest[0] as string,\n                topics: rest[1] as string[],\n                users: rest[2] as string[],\n                targets: rest[3] as string[],\n                draft: rest[4] as boolean,\n                scheduledAt: rest[5] as string            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const content = params.content;\n        const topics = params.topics;\n        const users = params.users;\n        const targets = params.targets;\n        const draft = params.draft;\n        const scheduledAt = params.scheduledAt;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n        if (typeof content === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"content\"');\n        }\n\n        const apiPath = '/messaging/messages/sms';\n        const payload: Payload = {};\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new SMS message.\n     *\n     * @param {string} params.messageId - Message ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.content - SMS Content.\n     * @param {string[]} params.topics - List of Topic IDs.\n     * @param {string[]} params.users - List of User IDs.\n     * @param {string[]} params.targets - List of Targets IDs.\n     * @param {boolean} params.draft - Is message a draft\n     * @param {string} params.scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     */\n    createSMS(params: { messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string  }): Promise<Models.Message>;\n    /**\n     * Create a new SMS message.\n     *\n     * @param {string} messageId - Message ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} content - SMS Content.\n     * @param {string[]} topics - List of Topic IDs.\n     * @param {string[]} users - List of User IDs.\n     * @param {string[]} targets - List of Targets IDs.\n     * @param {boolean} draft - Is message a draft\n     * @param {string} scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createSMS(messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string): Promise<Models.Message>;\n    createSMS(\n        paramsOrFirst: { messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string } | string,\n        ...rest: [(string)?, (string[])?, (string[])?, (string[])?, (boolean)?, (string)?]    \n    ): Promise<Models.Message> {\n        let params: { messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, content: string, topics?: string[], users?: string[], targets?: string[], draft?: boolean, scheduledAt?: string };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                content: rest[0] as string,\n                topics: rest[1] as string[],\n                users: rest[2] as string[],\n                targets: rest[3] as string[],\n                draft: rest[4] as boolean,\n                scheduledAt: rest[5] as string            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const content = params.content;\n        const topics = params.topics;\n        const users = params.users;\n        const targets = params.targets;\n        const draft = params.draft;\n        const scheduledAt = params.scheduledAt;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n        if (typeof content === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"content\"');\n        }\n\n        const apiPath = '/messaging/messages/sms';\n        const payload: Payload = {};\n        if (typeof messageId !== 'undefined') {\n            payload['messageId'] = messageId;\n        }\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update an SMS message by its unique ID. This endpoint only works on messages that are in draft status. Messages that are already processing, sent, or failed cannot be updated.\n     * \n     *\n     * @param {string} params.messageId - Message ID.\n     * @param {string[]} params.topics - List of Topic IDs.\n     * @param {string[]} params.users - List of User IDs.\n     * @param {string[]} params.targets - List of Targets IDs.\n     * @param {string} params.content - Email Content.\n     * @param {boolean} params.draft - Is message a draft\n     * @param {string} params.scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Messaging.updateSMS` instead.\n     */\n    updateSms(params: { messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string  }): Promise<Models.Message>;\n    /**\n     * Update an SMS message by its unique ID. This endpoint only works on messages that are in draft status. Messages that are already processing, sent, or failed cannot be updated.\n     * \n     *\n     * @param {string} messageId - Message ID.\n     * @param {string[]} topics - List of Topic IDs.\n     * @param {string[]} users - List of User IDs.\n     * @param {string[]} targets - List of Targets IDs.\n     * @param {string} content - Email Content.\n     * @param {boolean} draft - Is message a draft\n     * @param {string} scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateSms(messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string): Promise<Models.Message>;\n    updateSms(\n        paramsOrFirst: { messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string } | string,\n        ...rest: [(string[])?, (string[])?, (string[])?, (string)?, (boolean)?, (string)?]    \n    ): Promise<Models.Message> {\n        let params: { messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                topics: rest[0] as string[],\n                users: rest[1] as string[],\n                targets: rest[2] as string[],\n                content: rest[3] as string,\n                draft: rest[4] as boolean,\n                scheduledAt: rest[5] as string            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const topics = params.topics;\n        const users = params.users;\n        const targets = params.targets;\n        const content = params.content;\n        const draft = params.draft;\n        const scheduledAt = params.scheduledAt;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/sms/{messageId}'.replace('{messageId}', messageId);\n        const payload: Payload = {};\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update an SMS message by its unique ID. This endpoint only works on messages that are in draft status. Messages that are already processing, sent, or failed cannot be updated.\n     * \n     *\n     * @param {string} params.messageId - Message ID.\n     * @param {string[]} params.topics - List of Topic IDs.\n     * @param {string[]} params.users - List of User IDs.\n     * @param {string[]} params.targets - List of Targets IDs.\n     * @param {string} params.content - Email Content.\n     * @param {boolean} params.draft - Is message a draft\n     * @param {string} params.scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     */\n    updateSMS(params: { messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string  }): Promise<Models.Message>;\n    /**\n     * Update an SMS message by its unique ID. This endpoint only works on messages that are in draft status. Messages that are already processing, sent, or failed cannot be updated.\n     * \n     *\n     * @param {string} messageId - Message ID.\n     * @param {string[]} topics - List of Topic IDs.\n     * @param {string[]} users - List of User IDs.\n     * @param {string[]} targets - List of Targets IDs.\n     * @param {string} content - Email Content.\n     * @param {boolean} draft - Is message a draft\n     * @param {string} scheduledAt - Scheduled delivery time for message in [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format. DateTime value must be in future.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateSMS(messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string): Promise<Models.Message>;\n    updateSMS(\n        paramsOrFirst: { messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string } | string,\n        ...rest: [(string[])?, (string[])?, (string[])?, (string)?, (boolean)?, (string)?]    \n    ): Promise<Models.Message> {\n        let params: { messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, topics?: string[], users?: string[], targets?: string[], content?: string, draft?: boolean, scheduledAt?: string };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                topics: rest[0] as string[],\n                users: rest[1] as string[],\n                targets: rest[2] as string[],\n                content: rest[3] as string,\n                draft: rest[4] as boolean,\n                scheduledAt: rest[5] as string            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const topics = params.topics;\n        const users = params.users;\n        const targets = params.targets;\n        const content = params.content;\n        const draft = params.draft;\n        const scheduledAt = params.scheduledAt;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/sms/{messageId}'.replace('{messageId}', messageId);\n        const payload: Payload = {};\n        if (typeof topics !== 'undefined') {\n            payload['topics'] = topics;\n        }\n        if (typeof users !== 'undefined') {\n            payload['users'] = users;\n        }\n        if (typeof targets !== 'undefined') {\n            payload['targets'] = targets;\n        }\n        if (typeof content !== 'undefined') {\n            payload['content'] = content;\n        }\n        if (typeof draft !== 'undefined') {\n            payload['draft'] = draft;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a message by its unique ID.\n     * \n     *\n     * @param {string} params.messageId - Message ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     */\n    getMessage(params: { messageId: string  }): Promise<Models.Message>;\n    /**\n     * Get a message by its unique ID.\n     * \n     *\n     * @param {string} messageId - Message ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Message>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    getMessage(messageId: string): Promise<Models.Message>;\n    getMessage(\n        paramsOrFirst: { messageId: string } | string    \n    ): Promise<Models.Message> {\n        let params: { messageId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string            \n            };\n        }\n        \n        const messageId = params.messageId;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/{messageId}'.replace('{messageId}', messageId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Delete a message. If the message is not a draft or scheduled, but has been sent, this will not recall the message.\n     *\n     * @param {string} params.messageId - Message ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    delete(params: { messageId: string  }): Promise<{}>;\n    /**\n     * Delete a message. If the message is not a draft or scheduled, but has been sent, this will not recall the message.\n     *\n     * @param {string} messageId - Message ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    delete(messageId: string): Promise<{}>;\n    delete(\n        paramsOrFirst: { messageId: string } | string    \n    ): Promise<{}> {\n        let params: { messageId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string            \n            };\n        }\n        \n        const messageId = params.messageId;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/{messageId}'.replace('{messageId}', messageId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'delete',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get the message activity logs listed by its unique ID.\n     *\n     * @param {string} params.messageId - Message ID.\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LogList>}\n     */\n    listMessageLogs(params: { messageId: string, queries?: string[], total?: boolean  }): Promise<Models.LogList>;\n    /**\n     * Get the message activity logs listed by its unique ID.\n     *\n     * @param {string} messageId - Message ID.\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LogList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listMessageLogs(messageId: string, queries?: string[], total?: boolean): Promise<Models.LogList>;\n    listMessageLogs(\n        paramsOrFirst: { messageId: string, queries?: string[], total?: boolean } | string,\n        ...rest: [(string[])?, (boolean)?]    \n    ): Promise<Models.LogList> {\n        let params: { messageId: string, queries?: string[], total?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, queries?: string[], total?: boolean };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                queries: rest[0] as string[],\n                total: rest[1] as boolean            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const queries = params.queries;\n        const total = params.total;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/{messageId}/logs'.replace('{messageId}', messageId);\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a list of the targets associated with a message.\n     *\n     * @param {string} params.messageId - Message ID.\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: userId, providerId, identifier, providerType\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.TargetList>}\n     */\n    listTargets(params: { messageId: string, queries?: string[], total?: boolean  }): Promise<Models.TargetList>;\n    /**\n     * Get a list of the targets associated with a message.\n     *\n     * @param {string} messageId - Message ID.\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: userId, providerId, identifier, providerType\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.TargetList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listTargets(messageId: string, queries?: string[], total?: boolean): Promise<Models.TargetList>;\n    listTargets(\n        paramsOrFirst: { messageId: string, queries?: string[], total?: boolean } | string,\n        ...rest: [(string[])?, (boolean)?]    \n    ): Promise<Models.TargetList> {\n        let params: { messageId: string, queries?: string[], total?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { messageId: string, queries?: string[], total?: boolean };\n        } else {\n            params = {\n                messageId: paramsOrFirst as string,\n                queries: rest[0] as string[],\n                total: rest[1] as boolean            \n            };\n        }\n        \n        const messageId = params.messageId;\n        const queries = params.queries;\n        const total = params.total;\n\n        if (typeof messageId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"messageId\"');\n        }\n\n        const apiPath = '/messaging/messages/{messageId}/targets'.replace('{messageId}', messageId);\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a list of all providers from the current Appwrite project.\n     *\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, provider, type, enabled\n     * @param {string} params.search - Search term to filter your list results. Max length: 256 chars.\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ProviderList>}\n     */\n    listProviders(params?: { queries?: string[], search?: string, total?: boolean  }): Promise<Models.ProviderList>;\n    /**\n     * Get a list of all providers from the current Appwrite project.\n     *\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, provider, type, enabled\n     * @param {string} search - Search term to filter your list results. Max length: 256 chars.\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ProviderList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listProviders(queries?: string[], search?: string, total?: boolean): Promise<Models.ProviderList>;\n    listProviders(\n        paramsOrFirst?: { queries?: string[], search?: string, total?: boolean } | string[],\n        ...rest: [(string)?, (boolean)?]    \n    ): Promise<Models.ProviderList> {\n        let params: { queries?: string[], search?: string, total?: boolean };\n        \n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { queries?: string[], search?: string, total?: boolean };\n        } else {\n            params = {\n                queries: paramsOrFirst as string[],\n                search: rest[0] as string,\n                total: rest[1] as boolean            \n            };\n        }\n        \n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n\n\n        const apiPath = '/messaging/providers';\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Apple Push Notification service provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.authKey - APNS authentication key.\n     * @param {string} params.authKeyId - APNS authentication key ID.\n     * @param {string} params.teamId - APNS team ID.\n     * @param {string} params.bundleId - APNS bundle ID.\n     * @param {boolean} params.sandbox - Use APNS sandbox environment.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Messaging.createAPNSProvider` instead.\n     */\n    createApnsProvider(params: { providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Apple Push Notification service provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} authKey - APNS authentication key.\n     * @param {string} authKeyId - APNS authentication key ID.\n     * @param {string} teamId - APNS team ID.\n     * @param {string} bundleId - APNS bundle ID.\n     * @param {boolean} sandbox - Use APNS sandbox environment.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createApnsProvider(providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean): Promise<Models.Provider>;\n    createApnsProvider(\n        paramsOrFirst: { providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (string)?, (boolean)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                authKey: rest[1] as string,\n                authKeyId: rest[2] as string,\n                teamId: rest[3] as string,\n                bundleId: rest[4] as string,\n                sandbox: rest[5] as boolean,\n                enabled: rest[6] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const authKey = params.authKey;\n        const authKeyId = params.authKeyId;\n        const teamId = params.teamId;\n        const bundleId = params.bundleId;\n        const sandbox = params.sandbox;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/apns';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n        if (typeof authKeyId !== 'undefined') {\n            payload['authKeyId'] = authKeyId;\n        }\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n        if (typeof bundleId !== 'undefined') {\n            payload['bundleId'] = bundleId;\n        }\n        if (typeof sandbox !== 'undefined') {\n            payload['sandbox'] = sandbox;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Apple Push Notification service provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.authKey - APNS authentication key.\n     * @param {string} params.authKeyId - APNS authentication key ID.\n     * @param {string} params.teamId - APNS team ID.\n     * @param {string} params.bundleId - APNS bundle ID.\n     * @param {boolean} params.sandbox - Use APNS sandbox environment.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createAPNSProvider(params: { providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Apple Push Notification service provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} authKey - APNS authentication key.\n     * @param {string} authKeyId - APNS authentication key ID.\n     * @param {string} teamId - APNS team ID.\n     * @param {string} bundleId - APNS bundle ID.\n     * @param {boolean} sandbox - Use APNS sandbox environment.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createAPNSProvider(providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean): Promise<Models.Provider>;\n    createAPNSProvider(\n        paramsOrFirst: { providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (string)?, (boolean)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                authKey: rest[1] as string,\n                authKeyId: rest[2] as string,\n                teamId: rest[3] as string,\n                bundleId: rest[4] as string,\n                sandbox: rest[5] as boolean,\n                enabled: rest[6] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const authKey = params.authKey;\n        const authKeyId = params.authKeyId;\n        const teamId = params.teamId;\n        const bundleId = params.bundleId;\n        const sandbox = params.sandbox;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/apns';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n        if (typeof authKeyId !== 'undefined') {\n            payload['authKeyId'] = authKeyId;\n        }\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n        if (typeof bundleId !== 'undefined') {\n            payload['bundleId'] = bundleId;\n        }\n        if (typeof sandbox !== 'undefined') {\n            payload['sandbox'] = sandbox;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Apple Push Notification service provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.authKey - APNS authentication key.\n     * @param {string} params.authKeyId - APNS authentication key ID.\n     * @param {string} params.teamId - APNS team ID.\n     * @param {string} params.bundleId - APNS bundle ID.\n     * @param {boolean} params.sandbox - Use APNS sandbox environment.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Messaging.updateAPNSProvider` instead.\n     */\n    updateApnsProvider(params: { providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Update a Apple Push Notification service provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} authKey - APNS authentication key.\n     * @param {string} authKeyId - APNS authentication key ID.\n     * @param {string} teamId - APNS team ID.\n     * @param {string} bundleId - APNS bundle ID.\n     * @param {boolean} sandbox - Use APNS sandbox environment.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateApnsProvider(providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean): Promise<Models.Provider>;\n    updateApnsProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                authKey: rest[2] as string,\n                authKeyId: rest[3] as string,\n                teamId: rest[4] as string,\n                bundleId: rest[5] as string,\n                sandbox: rest[6] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const authKey = params.authKey;\n        const authKeyId = params.authKeyId;\n        const teamId = params.teamId;\n        const bundleId = params.bundleId;\n        const sandbox = params.sandbox;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/apns/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n        if (typeof authKeyId !== 'undefined') {\n            payload['authKeyId'] = authKeyId;\n        }\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n        if (typeof bundleId !== 'undefined') {\n            payload['bundleId'] = bundleId;\n        }\n        if (typeof sandbox !== 'undefined') {\n            payload['sandbox'] = sandbox;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Apple Push Notification service provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.authKey - APNS authentication key.\n     * @param {string} params.authKeyId - APNS authentication key ID.\n     * @param {string} params.teamId - APNS team ID.\n     * @param {string} params.bundleId - APNS bundle ID.\n     * @param {boolean} params.sandbox - Use APNS sandbox environment.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateAPNSProvider(params: { providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Update a Apple Push Notification service provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} authKey - APNS authentication key.\n     * @param {string} authKeyId - APNS authentication key ID.\n     * @param {string} teamId - APNS team ID.\n     * @param {string} bundleId - APNS bundle ID.\n     * @param {boolean} sandbox - Use APNS sandbox environment.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateAPNSProvider(providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean): Promise<Models.Provider>;\n    updateAPNSProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, authKey?: string, authKeyId?: string, teamId?: string, bundleId?: string, sandbox?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                authKey: rest[2] as string,\n                authKeyId: rest[3] as string,\n                teamId: rest[4] as string,\n                bundleId: rest[5] as string,\n                sandbox: rest[6] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const authKey = params.authKey;\n        const authKeyId = params.authKeyId;\n        const teamId = params.teamId;\n        const bundleId = params.bundleId;\n        const sandbox = params.sandbox;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/apns/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n        if (typeof authKeyId !== 'undefined') {\n            payload['authKeyId'] = authKeyId;\n        }\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n        if (typeof bundleId !== 'undefined') {\n            payload['bundleId'] = bundleId;\n        }\n        if (typeof sandbox !== 'undefined') {\n            payload['sandbox'] = sandbox;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Firebase Cloud Messaging provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {object} params.serviceAccountJSON - FCM service account JSON.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Messaging.createFCMProvider` instead.\n     */\n    createFcmProvider(params: { providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Firebase Cloud Messaging provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {object} serviceAccountJSON - FCM service account JSON.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createFcmProvider(providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean): Promise<Models.Provider>;\n    createFcmProvider(\n        paramsOrFirst: { providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean } | string,\n        ...rest: [(string)?, (object)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                serviceAccountJSON: rest[1] as object,\n                enabled: rest[2] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const serviceAccountJSON = params.serviceAccountJSON;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/fcm';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof serviceAccountJSON !== 'undefined') {\n            payload['serviceAccountJSON'] = serviceAccountJSON;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Firebase Cloud Messaging provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {object} params.serviceAccountJSON - FCM service account JSON.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createFCMProvider(params: { providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Firebase Cloud Messaging provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {object} serviceAccountJSON - FCM service account JSON.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createFCMProvider(providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean): Promise<Models.Provider>;\n    createFCMProvider(\n        paramsOrFirst: { providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean } | string,\n        ...rest: [(string)?, (object)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, serviceAccountJSON?: object, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                serviceAccountJSON: rest[1] as object,\n                enabled: rest[2] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const serviceAccountJSON = params.serviceAccountJSON;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/fcm';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof serviceAccountJSON !== 'undefined') {\n            payload['serviceAccountJSON'] = serviceAccountJSON;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Firebase Cloud Messaging provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {object} params.serviceAccountJSON - FCM service account JSON.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Messaging.updateFCMProvider` instead.\n     */\n    updateFcmProvider(params: { providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object  }): Promise<Models.Provider>;\n    /**\n     * Update a Firebase Cloud Messaging provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {object} serviceAccountJSON - FCM service account JSON.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateFcmProvider(providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object): Promise<Models.Provider>;\n    updateFcmProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object } | string,\n        ...rest: [(string)?, (boolean)?, (object)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                serviceAccountJSON: rest[2] as object            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const serviceAccountJSON = params.serviceAccountJSON;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/fcm/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof serviceAccountJSON !== 'undefined') {\n            payload['serviceAccountJSON'] = serviceAccountJSON;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Firebase Cloud Messaging provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {object} params.serviceAccountJSON - FCM service account JSON.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateFCMProvider(params: { providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object  }): Promise<Models.Provider>;\n    /**\n     * Update a Firebase Cloud Messaging provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {object} serviceAccountJSON - FCM service account JSON.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateFCMProvider(providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object): Promise<Models.Provider>;\n    updateFCMProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object } | string,\n        ...rest: [(string)?, (boolean)?, (object)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, serviceAccountJSON?: object };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                serviceAccountJSON: rest[2] as object            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const serviceAccountJSON = params.serviceAccountJSON;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/fcm/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof serviceAccountJSON !== 'undefined') {\n            payload['serviceAccountJSON'] = serviceAccountJSON;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Mailgun provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.apiKey - Mailgun API Key.\n     * @param {string} params.domain - Mailgun Domain.\n     * @param {boolean} params.isEuRegion - Set as EU region.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the reply to field for the mail. Default value is sender name. Reply to name must have reply to email as well.\n     * @param {string} params.replyToEmail - Email set in the reply to field for the mail. Default value is sender email. Reply to email must have reply to name as well.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createMailgunProvider(params: { providerId: string, name: string, apiKey?: string, domain?: string, isEuRegion?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Mailgun provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} apiKey - Mailgun API Key.\n     * @param {string} domain - Mailgun Domain.\n     * @param {boolean} isEuRegion - Set as EU region.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the reply to field for the mail. Default value is sender name. Reply to name must have reply to email as well.\n     * @param {string} replyToEmail - Email set in the reply to field for the mail. Default value is sender email. Reply to email must have reply to name as well.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createMailgunProvider(providerId: string, name: string, apiKey?: string, domain?: string, isEuRegion?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;\n    createMailgunProvider(\n        paramsOrFirst: { providerId: string, name: string, apiKey?: string, domain?: string, isEuRegion?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, apiKey?: string, domain?: string, isEuRegion?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, apiKey?: string, domain?: string, isEuRegion?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                apiKey: rest[1] as string,\n                domain: rest[2] as string,\n                isEuRegion: rest[3] as boolean,\n                fromName: rest[4] as string,\n                fromEmail: rest[5] as string,\n                replyToName: rest[6] as string,\n                replyToEmail: rest[7] as string,\n                enabled: rest[8] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const apiKey = params.apiKey;\n        const domain = params.domain;\n        const isEuRegion = params.isEuRegion;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/mailgun';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof domain !== 'undefined') {\n            payload['domain'] = domain;\n        }\n        if (typeof isEuRegion !== 'undefined') {\n            payload['isEuRegion'] = isEuRegion;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Mailgun provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.apiKey - Mailgun API Key.\n     * @param {string} params.domain - Mailgun Domain.\n     * @param {boolean} params.isEuRegion - Set as EU region.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} params.replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateMailgunProvider(params: { providerId: string, name?: string, apiKey?: string, domain?: string, isEuRegion?: boolean, enabled?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string  }): Promise<Models.Provider>;\n    /**\n     * Update a Mailgun provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {string} apiKey - Mailgun API Key.\n     * @param {string} domain - Mailgun Domain.\n     * @param {boolean} isEuRegion - Set as EU region.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateMailgunProvider(providerId: string, name?: string, apiKey?: string, domain?: string, isEuRegion?: boolean, enabled?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string): Promise<Models.Provider>;\n    updateMailgunProvider(\n        paramsOrFirst: { providerId: string, name?: string, apiKey?: string, domain?: string, isEuRegion?: boolean, enabled?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string } | string,\n        ...rest: [(string)?, (string)?, (string)?, (boolean)?, (boolean)?, (string)?, (string)?, (string)?, (string)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, apiKey?: string, domain?: string, isEuRegion?: boolean, enabled?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, apiKey?: string, domain?: string, isEuRegion?: boolean, enabled?: boolean, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                apiKey: rest[1] as string,\n                domain: rest[2] as string,\n                isEuRegion: rest[3] as boolean,\n                enabled: rest[4] as boolean,\n                fromName: rest[5] as string,\n                fromEmail: rest[6] as string,\n                replyToName: rest[7] as string,\n                replyToEmail: rest[8] as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const apiKey = params.apiKey;\n        const domain = params.domain;\n        const isEuRegion = params.isEuRegion;\n        const enabled = params.enabled;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/mailgun/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof domain !== 'undefined') {\n            payload['domain'] = domain;\n        }\n        if (typeof isEuRegion !== 'undefined') {\n            payload['isEuRegion'] = isEuRegion;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new MSG91 provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.templateId - Msg91 template ID\n     * @param {string} params.senderId - Msg91 sender ID.\n     * @param {string} params.authKey - Msg91 auth key.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createMsg91Provider(params: { providerId: string, name: string, templateId?: string, senderId?: string, authKey?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new MSG91 provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} templateId - Msg91 template ID\n     * @param {string} senderId - Msg91 sender ID.\n     * @param {string} authKey - Msg91 auth key.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createMsg91Provider(providerId: string, name: string, templateId?: string, senderId?: string, authKey?: string, enabled?: boolean): Promise<Models.Provider>;\n    createMsg91Provider(\n        paramsOrFirst: { providerId: string, name: string, templateId?: string, senderId?: string, authKey?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, templateId?: string, senderId?: string, authKey?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, templateId?: string, senderId?: string, authKey?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                templateId: rest[1] as string,\n                senderId: rest[2] as string,\n                authKey: rest[3] as string,\n                enabled: rest[4] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const templateId = params.templateId;\n        const senderId = params.senderId;\n        const authKey = params.authKey;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/msg91';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof templateId !== 'undefined') {\n            payload['templateId'] = templateId;\n        }\n        if (typeof senderId !== 'undefined') {\n            payload['senderId'] = senderId;\n        }\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a MSG91 provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.templateId - Msg91 template ID.\n     * @param {string} params.senderId - Msg91 sender ID.\n     * @param {string} params.authKey - Msg91 auth key.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateMsg91Provider(params: { providerId: string, name?: string, enabled?: boolean, templateId?: string, senderId?: string, authKey?: string  }): Promise<Models.Provider>;\n    /**\n     * Update a MSG91 provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} templateId - Msg91 template ID.\n     * @param {string} senderId - Msg91 sender ID.\n     * @param {string} authKey - Msg91 auth key.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateMsg91Provider(providerId: string, name?: string, enabled?: boolean, templateId?: string, senderId?: string, authKey?: string): Promise<Models.Provider>;\n    updateMsg91Provider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, templateId?: string, senderId?: string, authKey?: string } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, templateId?: string, senderId?: string, authKey?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, templateId?: string, senderId?: string, authKey?: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                templateId: rest[2] as string,\n                senderId: rest[3] as string,\n                authKey: rest[4] as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const templateId = params.templateId;\n        const senderId = params.senderId;\n        const authKey = params.authKey;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/msg91/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof templateId !== 'undefined') {\n            payload['templateId'] = templateId;\n        }\n        if (typeof senderId !== 'undefined') {\n            payload['senderId'] = senderId;\n        }\n        if (typeof authKey !== 'undefined') {\n            payload['authKey'] = authKey;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Resend provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.apiKey - Resend API key.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} params.replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createResendProvider(params: { providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Resend provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} apiKey - Resend API key.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createResendProvider(providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;\n    createResendProvider(\n        paramsOrFirst: { providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                apiKey: rest[1] as string,\n                fromName: rest[2] as string,\n                fromEmail: rest[3] as string,\n                replyToName: rest[4] as string,\n                replyToEmail: rest[5] as string,\n                enabled: rest[6] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const apiKey = params.apiKey;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/resend';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Resend provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.apiKey - Resend API key.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the Reply To field for the mail. Default value is Sender Name.\n     * @param {string} params.replyToEmail - Email set in the Reply To field for the mail. Default value is Sender Email.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateResendProvider(params: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string  }): Promise<Models.Provider>;\n    /**\n     * Update a Resend provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} apiKey - Resend API key.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the Reply To field for the mail. Default value is Sender Name.\n     * @param {string} replyToEmail - Email set in the Reply To field for the mail. Default value is Sender Email.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateResendProvider(providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string): Promise<Models.Provider>;\n    updateResendProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (string)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                apiKey: rest[2] as string,\n                fromName: rest[3] as string,\n                fromEmail: rest[4] as string,\n                replyToName: rest[5] as string,\n                replyToEmail: rest[6] as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const apiKey = params.apiKey;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/resend/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Sendgrid provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.apiKey - Sendgrid API key.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} params.replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createSendgridProvider(params: { providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Sendgrid provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} apiKey - Sendgrid API key.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createSendgridProvider(providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;\n    createSendgridProvider(\n        paramsOrFirst: { providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                apiKey: rest[1] as string,\n                fromName: rest[2] as string,\n                fromEmail: rest[3] as string,\n                replyToName: rest[4] as string,\n                replyToEmail: rest[5] as string,\n                enabled: rest[6] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const apiKey = params.apiKey;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/sendgrid';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Sendgrid provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.apiKey - Sendgrid API key.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the Reply To field for the mail. Default value is Sender Name.\n     * @param {string} params.replyToEmail - Email set in the Reply To field for the mail. Default value is Sender Email.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateSendgridProvider(params: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string  }): Promise<Models.Provider>;\n    /**\n     * Update a Sendgrid provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} apiKey - Sendgrid API key.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the Reply To field for the mail. Default value is Sender Name.\n     * @param {string} replyToEmail - Email set in the Reply To field for the mail. Default value is Sender Email.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateSendgridProvider(providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string): Promise<Models.Provider>;\n    updateSendgridProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (string)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, apiKey?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                apiKey: rest[2] as string,\n                fromName: rest[3] as string,\n                fromEmail: rest[4] as string,\n                replyToName: rest[5] as string,\n                replyToEmail: rest[6] as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const apiKey = params.apiKey;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/sendgrid/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new SMTP provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.host - SMTP hosts. Either a single hostname or multiple semicolon-delimited hostnames. You can also specify a different port for each host such as `smtp1.example.com:25;smtp2.example.com`. You can also specify encryption type, for example: `tls://smtp1.example.com:587;ssl://smtp2.example.com:465\"`. Hosts will be tried in order.\n     * @param {number} params.port - The default SMTP server port.\n     * @param {string} params.username - Authentication username.\n     * @param {string} params.password - Authentication password.\n     * @param {SmtpEncryption} params.encryption - Encryption type. Can be omitted, 'ssl', or 'tls'\n     * @param {boolean} params.autoTLS - Enable SMTP AutoTLS feature.\n     * @param {string} params.mailer - The value to use for the X-Mailer header.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} params.replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Messaging.createSMTPProvider` instead.\n     */\n    createSmtpProvider(params: { providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new SMTP provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} host - SMTP hosts. Either a single hostname or multiple semicolon-delimited hostnames. You can also specify a different port for each host such as `smtp1.example.com:25;smtp2.example.com`. You can also specify encryption type, for example: `tls://smtp1.example.com:587;ssl://smtp2.example.com:465\"`. Hosts will be tried in order.\n     * @param {number} port - The default SMTP server port.\n     * @param {string} username - Authentication username.\n     * @param {string} password - Authentication password.\n     * @param {SmtpEncryption} encryption - Encryption type. Can be omitted, 'ssl', or 'tls'\n     * @param {boolean} autoTLS - Enable SMTP AutoTLS feature.\n     * @param {string} mailer - The value to use for the X-Mailer header.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createSmtpProvider(providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;\n    createSmtpProvider(\n        paramsOrFirst: { providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (number)?, (string)?, (string)?, (SmtpEncryption)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                host: rest[1] as string,\n                port: rest[2] as number,\n                username: rest[3] as string,\n                password: rest[4] as string,\n                encryption: rest[5] as SmtpEncryption,\n                autoTLS: rest[6] as boolean,\n                mailer: rest[7] as string,\n                fromName: rest[8] as string,\n                fromEmail: rest[9] as string,\n                replyToName: rest[10] as string,\n                replyToEmail: rest[11] as string,\n                enabled: rest[12] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const host = params.host;\n        const port = params.port;\n        const username = params.username;\n        const password = params.password;\n        const encryption = params.encryption;\n        const autoTLS = params.autoTLS;\n        const mailer = params.mailer;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof host === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"host\"');\n        }\n\n        const apiPath = '/messaging/providers/smtp';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof host !== 'undefined') {\n            payload['host'] = host;\n        }\n        if (typeof port !== 'undefined') {\n            payload['port'] = port;\n        }\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n        if (typeof autoTLS !== 'undefined') {\n            payload['autoTLS'] = autoTLS;\n        }\n        if (typeof mailer !== 'undefined') {\n            payload['mailer'] = mailer;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new SMTP provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.host - SMTP hosts. Either a single hostname or multiple semicolon-delimited hostnames. You can also specify a different port for each host such as `smtp1.example.com:25;smtp2.example.com`. You can also specify encryption type, for example: `tls://smtp1.example.com:587;ssl://smtp2.example.com:465\"`. Hosts will be tried in order.\n     * @param {number} params.port - The default SMTP server port.\n     * @param {string} params.username - Authentication username.\n     * @param {string} params.password - Authentication password.\n     * @param {SmtpEncryption} params.encryption - Encryption type. Can be omitted, 'ssl', or 'tls'\n     * @param {boolean} params.autoTLS - Enable SMTP AutoTLS feature.\n     * @param {string} params.mailer - The value to use for the X-Mailer header.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} params.replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createSMTPProvider(params: { providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new SMTP provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} host - SMTP hosts. Either a single hostname or multiple semicolon-delimited hostnames. You can also specify a different port for each host such as `smtp1.example.com:25;smtp2.example.com`. You can also specify encryption type, for example: `tls://smtp1.example.com:587;ssl://smtp2.example.com:465\"`. Hosts will be tried in order.\n     * @param {number} port - The default SMTP server port.\n     * @param {string} username - Authentication username.\n     * @param {string} password - Authentication password.\n     * @param {SmtpEncryption} encryption - Encryption type. Can be omitted, 'ssl', or 'tls'\n     * @param {boolean} autoTLS - Enable SMTP AutoTLS feature.\n     * @param {string} mailer - The value to use for the X-Mailer header.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the reply to field for the mail. Default value is sender name.\n     * @param {string} replyToEmail - Email set in the reply to field for the mail. Default value is sender email.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createSMTPProvider(providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;\n    createSMTPProvider(\n        paramsOrFirst: { providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (number)?, (string)?, (string)?, (SmtpEncryption)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, host: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                host: rest[1] as string,\n                port: rest[2] as number,\n                username: rest[3] as string,\n                password: rest[4] as string,\n                encryption: rest[5] as SmtpEncryption,\n                autoTLS: rest[6] as boolean,\n                mailer: rest[7] as string,\n                fromName: rest[8] as string,\n                fromEmail: rest[9] as string,\n                replyToName: rest[10] as string,\n                replyToEmail: rest[11] as string,\n                enabled: rest[12] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const host = params.host;\n        const port = params.port;\n        const username = params.username;\n        const password = params.password;\n        const encryption = params.encryption;\n        const autoTLS = params.autoTLS;\n        const mailer = params.mailer;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        if (typeof host === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"host\"');\n        }\n\n        const apiPath = '/messaging/providers/smtp';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof host !== 'undefined') {\n            payload['host'] = host;\n        }\n        if (typeof port !== 'undefined') {\n            payload['port'] = port;\n        }\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n        if (typeof autoTLS !== 'undefined') {\n            payload['autoTLS'] = autoTLS;\n        }\n        if (typeof mailer !== 'undefined') {\n            payload['mailer'] = mailer;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a SMTP provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.host - SMTP hosts. Either a single hostname or multiple semicolon-delimited hostnames. You can also specify a different port for each host such as `smtp1.example.com:25;smtp2.example.com`. You can also specify encryption type, for example: `tls://smtp1.example.com:587;ssl://smtp2.example.com:465\"`. Hosts will be tried in order.\n     * @param {number} params.port - SMTP port.\n     * @param {string} params.username - Authentication username.\n     * @param {string} params.password - Authentication password.\n     * @param {SmtpEncryption} params.encryption - Encryption type. Can be 'ssl' or 'tls'\n     * @param {boolean} params.autoTLS - Enable SMTP AutoTLS feature.\n     * @param {string} params.mailer - The value to use for the X-Mailer header.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the Reply To field for the mail. Default value is Sender Name.\n     * @param {string} params.replyToEmail - Email set in the Reply To field for the mail. Default value is Sender Email.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Messaging.updateSMTPProvider` instead.\n     */\n    updateSmtpProvider(params: { providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Update a SMTP provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {string} host - SMTP hosts. Either a single hostname or multiple semicolon-delimited hostnames. You can also specify a different port for each host such as `smtp1.example.com:25;smtp2.example.com`. You can also specify encryption type, for example: `tls://smtp1.example.com:587;ssl://smtp2.example.com:465\"`. Hosts will be tried in order.\n     * @param {number} port - SMTP port.\n     * @param {string} username - Authentication username.\n     * @param {string} password - Authentication password.\n     * @param {SmtpEncryption} encryption - Encryption type. Can be 'ssl' or 'tls'\n     * @param {boolean} autoTLS - Enable SMTP AutoTLS feature.\n     * @param {string} mailer - The value to use for the X-Mailer header.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the Reply To field for the mail. Default value is Sender Name.\n     * @param {string} replyToEmail - Email set in the Reply To field for the mail. Default value is Sender Email.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateSmtpProvider(providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;\n    updateSmtpProvider(\n        paramsOrFirst: { providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (number)?, (string)?, (string)?, (SmtpEncryption)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                host: rest[1] as string,\n                port: rest[2] as number,\n                username: rest[3] as string,\n                password: rest[4] as string,\n                encryption: rest[5] as SmtpEncryption,\n                autoTLS: rest[6] as boolean,\n                mailer: rest[7] as string,\n                fromName: rest[8] as string,\n                fromEmail: rest[9] as string,\n                replyToName: rest[10] as string,\n                replyToEmail: rest[11] as string,\n                enabled: rest[12] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const host = params.host;\n        const port = params.port;\n        const username = params.username;\n        const password = params.password;\n        const encryption = params.encryption;\n        const autoTLS = params.autoTLS;\n        const mailer = params.mailer;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/smtp/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof host !== 'undefined') {\n            payload['host'] = host;\n        }\n        if (typeof port !== 'undefined') {\n            payload['port'] = port;\n        }\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n        if (typeof autoTLS !== 'undefined') {\n            payload['autoTLS'] = autoTLS;\n        }\n        if (typeof mailer !== 'undefined') {\n            payload['mailer'] = mailer;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a SMTP provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.host - SMTP hosts. Either a single hostname or multiple semicolon-delimited hostnames. You can also specify a different port for each host such as `smtp1.example.com:25;smtp2.example.com`. You can also specify encryption type, for example: `tls://smtp1.example.com:587;ssl://smtp2.example.com:465\"`. Hosts will be tried in order.\n     * @param {number} params.port - SMTP port.\n     * @param {string} params.username - Authentication username.\n     * @param {string} params.password - Authentication password.\n     * @param {SmtpEncryption} params.encryption - Encryption type. Can be 'ssl' or 'tls'\n     * @param {boolean} params.autoTLS - Enable SMTP AutoTLS feature.\n     * @param {string} params.mailer - The value to use for the X-Mailer header.\n     * @param {string} params.fromName - Sender Name.\n     * @param {string} params.fromEmail - Sender email address.\n     * @param {string} params.replyToName - Name set in the Reply To field for the mail. Default value is Sender Name.\n     * @param {string} params.replyToEmail - Email set in the Reply To field for the mail. Default value is Sender Email.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateSMTPProvider(params: { providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Update a SMTP provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {string} host - SMTP hosts. Either a single hostname or multiple semicolon-delimited hostnames. You can also specify a different port for each host such as `smtp1.example.com:25;smtp2.example.com`. You can also specify encryption type, for example: `tls://smtp1.example.com:587;ssl://smtp2.example.com:465\"`. Hosts will be tried in order.\n     * @param {number} port - SMTP port.\n     * @param {string} username - Authentication username.\n     * @param {string} password - Authentication password.\n     * @param {SmtpEncryption} encryption - Encryption type. Can be 'ssl' or 'tls'\n     * @param {boolean} autoTLS - Enable SMTP AutoTLS feature.\n     * @param {string} mailer - The value to use for the X-Mailer header.\n     * @param {string} fromName - Sender Name.\n     * @param {string} fromEmail - Sender email address.\n     * @param {string} replyToName - Name set in the Reply To field for the mail. Default value is Sender Name.\n     * @param {string} replyToEmail - Email set in the Reply To field for the mail. Default value is Sender Email.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateSMTPProvider(providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean): Promise<Models.Provider>;\n    updateSMTPProvider(\n        paramsOrFirst: { providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (number)?, (string)?, (string)?, (SmtpEncryption)?, (boolean)?, (string)?, (string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, host?: string, port?: number, username?: string, password?: string, encryption?: SmtpEncryption, autoTLS?: boolean, mailer?: string, fromName?: string, fromEmail?: string, replyToName?: string, replyToEmail?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                host: rest[1] as string,\n                port: rest[2] as number,\n                username: rest[3] as string,\n                password: rest[4] as string,\n                encryption: rest[5] as SmtpEncryption,\n                autoTLS: rest[6] as boolean,\n                mailer: rest[7] as string,\n                fromName: rest[8] as string,\n                fromEmail: rest[9] as string,\n                replyToName: rest[10] as string,\n                replyToEmail: rest[11] as string,\n                enabled: rest[12] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const host = params.host;\n        const port = params.port;\n        const username = params.username;\n        const password = params.password;\n        const encryption = params.encryption;\n        const autoTLS = params.autoTLS;\n        const mailer = params.mailer;\n        const fromName = params.fromName;\n        const fromEmail = params.fromEmail;\n        const replyToName = params.replyToName;\n        const replyToEmail = params.replyToEmail;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/smtp/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof host !== 'undefined') {\n            payload['host'] = host;\n        }\n        if (typeof port !== 'undefined') {\n            payload['port'] = port;\n        }\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof encryption !== 'undefined') {\n            payload['encryption'] = encryption;\n        }\n        if (typeof autoTLS !== 'undefined') {\n            payload['autoTLS'] = autoTLS;\n        }\n        if (typeof mailer !== 'undefined') {\n            payload['mailer'] = mailer;\n        }\n        if (typeof fromName !== 'undefined') {\n            payload['fromName'] = fromName;\n        }\n        if (typeof fromEmail !== 'undefined') {\n            payload['fromEmail'] = fromEmail;\n        }\n        if (typeof replyToName !== 'undefined') {\n            payload['replyToName'] = replyToName;\n        }\n        if (typeof replyToEmail !== 'undefined') {\n            payload['replyToEmail'] = replyToEmail;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Telesign provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.from - Sender Phone number. Format this number with a leading '+' and a country code, e.g., +16175551212.\n     * @param {string} params.customerId - Telesign customer ID.\n     * @param {string} params.apiKey - Telesign API key.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createTelesignProvider(params: { providerId: string, name: string, from?: string, customerId?: string, apiKey?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Telesign provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} from - Sender Phone number. Format this number with a leading '+' and a country code, e.g., +16175551212.\n     * @param {string} customerId - Telesign customer ID.\n     * @param {string} apiKey - Telesign API key.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createTelesignProvider(providerId: string, name: string, from?: string, customerId?: string, apiKey?: string, enabled?: boolean): Promise<Models.Provider>;\n    createTelesignProvider(\n        paramsOrFirst: { providerId: string, name: string, from?: string, customerId?: string, apiKey?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, from?: string, customerId?: string, apiKey?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, from?: string, customerId?: string, apiKey?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                from: rest[1] as string,\n                customerId: rest[2] as string,\n                apiKey: rest[3] as string,\n                enabled: rest[4] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const from = params.from;\n        const customerId = params.customerId;\n        const apiKey = params.apiKey;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/telesign';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n        if (typeof customerId !== 'undefined') {\n            payload['customerId'] = customerId;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Telesign provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.customerId - Telesign customer ID.\n     * @param {string} params.apiKey - Telesign API key.\n     * @param {string} params.from - Sender number.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateTelesignProvider(params: { providerId: string, name?: string, enabled?: boolean, customerId?: string, apiKey?: string, from?: string  }): Promise<Models.Provider>;\n    /**\n     * Update a Telesign provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} customerId - Telesign customer ID.\n     * @param {string} apiKey - Telesign API key.\n     * @param {string} from - Sender number.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateTelesignProvider(providerId: string, name?: string, enabled?: boolean, customerId?: string, apiKey?: string, from?: string): Promise<Models.Provider>;\n    updateTelesignProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, customerId?: string, apiKey?: string, from?: string } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, customerId?: string, apiKey?: string, from?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, customerId?: string, apiKey?: string, from?: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                customerId: rest[2] as string,\n                apiKey: rest[3] as string,\n                from: rest[4] as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const customerId = params.customerId;\n        const apiKey = params.apiKey;\n        const from = params.from;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/telesign/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof customerId !== 'undefined') {\n            payload['customerId'] = customerId;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Textmagic provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.from - Sender Phone number. Format this number with a leading '+' and a country code, e.g., +16175551212.\n     * @param {string} params.username - Textmagic username.\n     * @param {string} params.apiKey - Textmagic apiKey.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createTextmagicProvider(params: { providerId: string, name: string, from?: string, username?: string, apiKey?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Textmagic provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} from - Sender Phone number. Format this number with a leading '+' and a country code, e.g., +16175551212.\n     * @param {string} username - Textmagic username.\n     * @param {string} apiKey - Textmagic apiKey.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createTextmagicProvider(providerId: string, name: string, from?: string, username?: string, apiKey?: string, enabled?: boolean): Promise<Models.Provider>;\n    createTextmagicProvider(\n        paramsOrFirst: { providerId: string, name: string, from?: string, username?: string, apiKey?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, from?: string, username?: string, apiKey?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, from?: string, username?: string, apiKey?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                from: rest[1] as string,\n                username: rest[2] as string,\n                apiKey: rest[3] as string,\n                enabled: rest[4] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const from = params.from;\n        const username = params.username;\n        const apiKey = params.apiKey;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/textmagic';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Textmagic provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.username - Textmagic username.\n     * @param {string} params.apiKey - Textmagic apiKey.\n     * @param {string} params.from - Sender number.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateTextmagicProvider(params: { providerId: string, name?: string, enabled?: boolean, username?: string, apiKey?: string, from?: string  }): Promise<Models.Provider>;\n    /**\n     * Update a Textmagic provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} username - Textmagic username.\n     * @param {string} apiKey - Textmagic apiKey.\n     * @param {string} from - Sender number.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateTextmagicProvider(providerId: string, name?: string, enabled?: boolean, username?: string, apiKey?: string, from?: string): Promise<Models.Provider>;\n    updateTextmagicProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, username?: string, apiKey?: string, from?: string } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, username?: string, apiKey?: string, from?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, username?: string, apiKey?: string, from?: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                username: rest[2] as string,\n                apiKey: rest[3] as string,\n                from: rest[4] as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const username = params.username;\n        const apiKey = params.apiKey;\n        const from = params.from;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/textmagic/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof username !== 'undefined') {\n            payload['username'] = username;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Twilio provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.from - Sender Phone number. Format this number with a leading '+' and a country code, e.g., +16175551212.\n     * @param {string} params.accountSid - Twilio account secret ID.\n     * @param {string} params.authToken - Twilio authentication token.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createTwilioProvider(params: { providerId: string, name: string, from?: string, accountSid?: string, authToken?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Twilio provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} from - Sender Phone number. Format this number with a leading '+' and a country code, e.g., +16175551212.\n     * @param {string} accountSid - Twilio account secret ID.\n     * @param {string} authToken - Twilio authentication token.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createTwilioProvider(providerId: string, name: string, from?: string, accountSid?: string, authToken?: string, enabled?: boolean): Promise<Models.Provider>;\n    createTwilioProvider(\n        paramsOrFirst: { providerId: string, name: string, from?: string, accountSid?: string, authToken?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, from?: string, accountSid?: string, authToken?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, from?: string, accountSid?: string, authToken?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                from: rest[1] as string,\n                accountSid: rest[2] as string,\n                authToken: rest[3] as string,\n                enabled: rest[4] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const from = params.from;\n        const accountSid = params.accountSid;\n        const authToken = params.authToken;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/twilio';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n        if (typeof accountSid !== 'undefined') {\n            payload['accountSid'] = accountSid;\n        }\n        if (typeof authToken !== 'undefined') {\n            payload['authToken'] = authToken;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Twilio provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.accountSid - Twilio account secret ID.\n     * @param {string} params.authToken - Twilio authentication token.\n     * @param {string} params.from - Sender number.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateTwilioProvider(params: { providerId: string, name?: string, enabled?: boolean, accountSid?: string, authToken?: string, from?: string  }): Promise<Models.Provider>;\n    /**\n     * Update a Twilio provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} accountSid - Twilio account secret ID.\n     * @param {string} authToken - Twilio authentication token.\n     * @param {string} from - Sender number.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateTwilioProvider(providerId: string, name?: string, enabled?: boolean, accountSid?: string, authToken?: string, from?: string): Promise<Models.Provider>;\n    updateTwilioProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, accountSid?: string, authToken?: string, from?: string } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, accountSid?: string, authToken?: string, from?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, accountSid?: string, authToken?: string, from?: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                accountSid: rest[2] as string,\n                authToken: rest[3] as string,\n                from: rest[4] as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const accountSid = params.accountSid;\n        const authToken = params.authToken;\n        const from = params.from;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/twilio/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof accountSid !== 'undefined') {\n            payload['accountSid'] = accountSid;\n        }\n        if (typeof authToken !== 'undefined') {\n            payload['authToken'] = authToken;\n        }\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new Vonage provider.\n     *\n     * @param {string} params.providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} params.name - Provider name.\n     * @param {string} params.from - Sender Phone number. Format this number with a leading '+' and a country code, e.g., +16175551212.\n     * @param {string} params.apiKey - Vonage API key.\n     * @param {string} params.apiSecret - Vonage API secret.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    createVonageProvider(params: { providerId: string, name: string, from?: string, apiKey?: string, apiSecret?: string, enabled?: boolean  }): Promise<Models.Provider>;\n    /**\n     * Create a new Vonage provider.\n     *\n     * @param {string} providerId - Provider ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can't start with a special char. Max length is 36 chars.\n     * @param {string} name - Provider name.\n     * @param {string} from - Sender Phone number. Format this number with a leading '+' and a country code, e.g., +16175551212.\n     * @param {string} apiKey - Vonage API key.\n     * @param {string} apiSecret - Vonage API secret.\n     * @param {boolean} enabled - Set as enabled.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createVonageProvider(providerId: string, name: string, from?: string, apiKey?: string, apiSecret?: string, enabled?: boolean): Promise<Models.Provider>;\n    createVonageProvider(\n        paramsOrFirst: { providerId: string, name: string, from?: string, apiKey?: string, apiSecret?: string, enabled?: boolean } | string,\n        ...rest: [(string)?, (string)?, (string)?, (string)?, (boolean)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name: string, from?: string, apiKey?: string, apiSecret?: string, enabled?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name: string, from?: string, apiKey?: string, apiSecret?: string, enabled?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                from: rest[1] as string,\n                apiKey: rest[2] as string,\n                apiSecret: rest[3] as string,\n                enabled: rest[4] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const from = params.from;\n        const apiKey = params.apiKey;\n        const apiSecret = params.apiSecret;\n        const enabled = params.enabled;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/providers/vonage';\n        const payload: Payload = {};\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof apiSecret !== 'undefined') {\n            payload['apiSecret'] = apiSecret;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a Vonage provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string} params.name - Provider name.\n     * @param {boolean} params.enabled - Set as enabled.\n     * @param {string} params.apiKey - Vonage API key.\n     * @param {string} params.apiSecret - Vonage API secret.\n     * @param {string} params.from - Sender number.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    updateVonageProvider(params: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, apiSecret?: string, from?: string  }): Promise<Models.Provider>;\n    /**\n     * Update a Vonage provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string} name - Provider name.\n     * @param {boolean} enabled - Set as enabled.\n     * @param {string} apiKey - Vonage API key.\n     * @param {string} apiSecret - Vonage API secret.\n     * @param {string} from - Sender number.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateVonageProvider(providerId: string, name?: string, enabled?: boolean, apiKey?: string, apiSecret?: string, from?: string): Promise<Models.Provider>;\n    updateVonageProvider(\n        paramsOrFirst: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, apiSecret?: string, from?: string } | string,\n        ...rest: [(string)?, (boolean)?, (string)?, (string)?, (string)?]    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string, name?: string, enabled?: boolean, apiKey?: string, apiSecret?: string, from?: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, name?: string, enabled?: boolean, apiKey?: string, apiSecret?: string, from?: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                name: rest[0] as string,\n                enabled: rest[1] as boolean,\n                apiKey: rest[2] as string,\n                apiSecret: rest[3] as string,\n                from: rest[4] as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const name = params.name;\n        const enabled = params.enabled;\n        const apiKey = params.apiKey;\n        const apiSecret = params.apiSecret;\n        const from = params.from;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/vonage/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof enabled !== 'undefined') {\n            payload['enabled'] = enabled;\n        }\n        if (typeof apiKey !== 'undefined') {\n            payload['apiKey'] = apiKey;\n        }\n        if (typeof apiSecret !== 'undefined') {\n            payload['apiSecret'] = apiSecret;\n        }\n        if (typeof from !== 'undefined') {\n            payload['from'] = from;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a provider by its unique ID.\n     * \n     *\n     * @param {string} params.providerId - Provider ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     */\n    getProvider(params: { providerId: string  }): Promise<Models.Provider>;\n    /**\n     * Get a provider by its unique ID.\n     * \n     *\n     * @param {string} providerId - Provider ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Provider>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    getProvider(providerId: string): Promise<Models.Provider>;\n    getProvider(\n        paramsOrFirst: { providerId: string } | string    \n    ): Promise<Models.Provider> {\n        let params: { providerId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Delete a provider by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    deleteProvider(params: { providerId: string  }): Promise<{}>;\n    /**\n     * Delete a provider by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    deleteProvider(providerId: string): Promise<{}>;\n    deleteProvider(\n        paramsOrFirst: { providerId: string } | string    \n    ): Promise<{}> {\n        let params: { providerId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string            \n            };\n        }\n        \n        const providerId = params.providerId;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/{providerId}'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'delete',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get the provider activity logs listed by its unique ID.\n     *\n     * @param {string} params.providerId - Provider ID.\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LogList>}\n     */\n    listProviderLogs(params: { providerId: string, queries?: string[], total?: boolean  }): Promise<Models.LogList>;\n    /**\n     * Get the provider activity logs listed by its unique ID.\n     *\n     * @param {string} providerId - Provider ID.\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LogList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listProviderLogs(providerId: string, queries?: string[], total?: boolean): Promise<Models.LogList>;\n    listProviderLogs(\n        paramsOrFirst: { providerId: string, queries?: string[], total?: boolean } | string,\n        ...rest: [(string[])?, (boolean)?]    \n    ): Promise<Models.LogList> {\n        let params: { providerId: string, queries?: string[], total?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { providerId: string, queries?: string[], total?: boolean };\n        } else {\n            params = {\n                providerId: paramsOrFirst as string,\n                queries: rest[0] as string[],\n                total: rest[1] as boolean            \n            };\n        }\n        \n        const providerId = params.providerId;\n        const queries = params.queries;\n        const total = params.total;\n\n        if (typeof providerId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"providerId\"');\n        }\n\n        const apiPath = '/messaging/providers/{providerId}/logs'.replace('{providerId}', providerId);\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get the subscriber activity logs listed by its unique ID.\n     *\n     * @param {string} params.subscriberId - Subscriber ID.\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LogList>}\n     */\n    listSubscriberLogs(params: { subscriberId: string, queries?: string[], total?: boolean  }): Promise<Models.LogList>;\n    /**\n     * Get the subscriber activity logs listed by its unique ID.\n     *\n     * @param {string} subscriberId - Subscriber ID.\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LogList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listSubscriberLogs(subscriberId: string, queries?: string[], total?: boolean): Promise<Models.LogList>;\n    listSubscriberLogs(\n        paramsOrFirst: { subscriberId: string, queries?: string[], total?: boolean } | string,\n        ...rest: [(string[])?, (boolean)?]    \n    ): Promise<Models.LogList> {\n        let params: { subscriberId: string, queries?: string[], total?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { subscriberId: string, queries?: string[], total?: boolean };\n        } else {\n            params = {\n                subscriberId: paramsOrFirst as string,\n                queries: rest[0] as string[],\n                total: rest[1] as boolean            \n            };\n        }\n        \n        const subscriberId = params.subscriberId;\n        const queries = params.queries;\n        const total = params.total;\n\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n        const apiPath = '/messaging/subscribers/{subscriberId}/logs'.replace('{subscriberId}', subscriberId);\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a list of all topics from the current Appwrite project.\n     *\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, description, emailTotal, smsTotal, pushTotal\n     * @param {string} params.search - Search term to filter your list results. Max length: 256 chars.\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.TopicList>}\n     */\n    listTopics(params?: { queries?: string[], search?: string, total?: boolean  }): Promise<Models.TopicList>;\n    /**\n     * Get a list of all topics from the current Appwrite project.\n     *\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, description, emailTotal, smsTotal, pushTotal\n     * @param {string} search - Search term to filter your list results. Max length: 256 chars.\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.TopicList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listTopics(queries?: string[], search?: string, total?: boolean): Promise<Models.TopicList>;\n    listTopics(\n        paramsOrFirst?: { queries?: string[], search?: string, total?: boolean } | string[],\n        ...rest: [(string)?, (boolean)?]    \n    ): Promise<Models.TopicList> {\n        let params: { queries?: string[], search?: string, total?: boolean };\n        \n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { queries?: string[], search?: string, total?: boolean };\n        } else {\n            params = {\n                queries: paramsOrFirst as string[],\n                search: rest[0] as string,\n                total: rest[1] as boolean            \n            };\n        }\n        \n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n\n\n        const apiPath = '/messaging/topics';\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new topic.\n     *\n     * @param {string} params.topicId - Topic ID. Choose a custom Topic ID or a new Topic ID.\n     * @param {string} params.name - Topic Name.\n     * @param {string[]} params.subscribe - An array of role strings with subscribe permission. By default all users are granted with any subscribe permission. [learn more about roles](https://appwrite.io/docs/permissions#permission-roles). Maximum of 100 roles are allowed, each 64 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Topic>}\n     */\n    createTopic(params: { topicId: string, name: string, subscribe?: string[]  }): Promise<Models.Topic>;\n    /**\n     * Create a new topic.\n     *\n     * @param {string} topicId - Topic ID. Choose a custom Topic ID or a new Topic ID.\n     * @param {string} name - Topic Name.\n     * @param {string[]} subscribe - An array of role strings with subscribe permission. By default all users are granted with any subscribe permission. [learn more about roles](https://appwrite.io/docs/permissions#permission-roles). Maximum of 100 roles are allowed, each 64 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Topic>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createTopic(topicId: string, name: string, subscribe?: string[]): Promise<Models.Topic>;\n    createTopic(\n        paramsOrFirst: { topicId: string, name: string, subscribe?: string[] } | string,\n        ...rest: [(string)?, (string[])?]    \n    ): Promise<Models.Topic> {\n        let params: { topicId: string, name: string, subscribe?: string[] };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string, name: string, subscribe?: string[] };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string,\n                name: rest[0] as string,\n                subscribe: rest[1] as string[]            \n            };\n        }\n        \n        const topicId = params.topicId;\n        const name = params.name;\n        const subscribe = params.subscribe;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n\n        const apiPath = '/messaging/topics';\n        const payload: Payload = {};\n        if (typeof topicId !== 'undefined') {\n            payload['topicId'] = topicId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof subscribe !== 'undefined') {\n            payload['subscribe'] = subscribe;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a topic by its unique ID.\n     * \n     *\n     * @param {string} params.topicId - Topic ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Topic>}\n     */\n    getTopic(params: { topicId: string  }): Promise<Models.Topic>;\n    /**\n     * Get a topic by its unique ID.\n     * \n     *\n     * @param {string} topicId - Topic ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Topic>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    getTopic(topicId: string): Promise<Models.Topic>;\n    getTopic(\n        paramsOrFirst: { topicId: string } | string    \n    ): Promise<Models.Topic> {\n        let params: { topicId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string            \n            };\n        }\n        \n        const topicId = params.topicId;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Update a topic by its unique ID.\n     * \n     *\n     * @param {string} params.topicId - Topic ID.\n     * @param {string} params.name - Topic Name.\n     * @param {string[]} params.subscribe - An array of role strings with subscribe permission. By default all users are granted with any subscribe permission. [learn more about roles](https://appwrite.io/docs/permissions#permission-roles). Maximum of 100 roles are allowed, each 64 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Topic>}\n     */\n    updateTopic(params: { topicId: string, name?: string, subscribe?: string[]  }): Promise<Models.Topic>;\n    /**\n     * Update a topic by its unique ID.\n     * \n     *\n     * @param {string} topicId - Topic ID.\n     * @param {string} name - Topic Name.\n     * @param {string[]} subscribe - An array of role strings with subscribe permission. By default all users are granted with any subscribe permission. [learn more about roles](https://appwrite.io/docs/permissions#permission-roles). Maximum of 100 roles are allowed, each 64 characters long.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Topic>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    updateTopic(topicId: string, name?: string, subscribe?: string[]): Promise<Models.Topic>;\n    updateTopic(\n        paramsOrFirst: { topicId: string, name?: string, subscribe?: string[] } | string,\n        ...rest: [(string)?, (string[])?]    \n    ): Promise<Models.Topic> {\n        let params: { topicId: string, name?: string, subscribe?: string[] };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string, name?: string, subscribe?: string[] };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string,\n                name: rest[0] as string,\n                subscribe: rest[1] as string[]            \n            };\n        }\n        \n        const topicId = params.topicId;\n        const name = params.name;\n        const subscribe = params.subscribe;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        const payload: Payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof subscribe !== 'undefined') {\n            payload['subscribe'] = subscribe;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'patch',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Delete a topic by its unique ID.\n     *\n     * @param {string} params.topicId - Topic ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    deleteTopic(params: { topicId: string  }): Promise<{}>;\n    /**\n     * Delete a topic by its unique ID.\n     *\n     * @param {string} topicId - Topic ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    deleteTopic(topicId: string): Promise<{}>;\n    deleteTopic(\n        paramsOrFirst: { topicId: string } | string    \n    ): Promise<{}> {\n        let params: { topicId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string            \n            };\n        }\n        \n        const topicId = params.topicId;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        const apiPath = '/messaging/topics/{topicId}'.replace('{topicId}', topicId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'delete',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get the topic activity logs listed by its unique ID.\n     *\n     * @param {string} params.topicId - Topic ID.\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LogList>}\n     */\n    listTopicLogs(params: { topicId: string, queries?: string[], total?: boolean  }): Promise<Models.LogList>;\n    /**\n     * Get the topic activity logs listed by its unique ID.\n     *\n     * @param {string} topicId - Topic ID.\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Only supported methods are limit and offset\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LogList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listTopicLogs(topicId: string, queries?: string[], total?: boolean): Promise<Models.LogList>;\n    listTopicLogs(\n        paramsOrFirst: { topicId: string, queries?: string[], total?: boolean } | string,\n        ...rest: [(string[])?, (boolean)?]    \n    ): Promise<Models.LogList> {\n        let params: { topicId: string, queries?: string[], total?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string, queries?: string[], total?: boolean };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string,\n                queries: rest[0] as string[],\n                total: rest[1] as boolean            \n            };\n        }\n        \n        const topicId = params.topicId;\n        const queries = params.queries;\n        const total = params.total;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        const apiPath = '/messaging/topics/{topicId}/logs'.replace('{topicId}', topicId);\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a list of all subscribers from the current Appwrite project.\n     *\n     * @param {string} params.topicId - Topic ID. The topic ID subscribed to.\n     * @param {string[]} params.queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, provider, type, enabled\n     * @param {string} params.search - Search term to filter your list results. Max length: 256 chars.\n     * @param {boolean} params.total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.SubscriberList>}\n     */\n    listSubscribers(params: { topicId: string, queries?: string[], search?: string, total?: boolean  }): Promise<Models.SubscriberList>;\n    /**\n     * Get a list of all subscribers from the current Appwrite project.\n     *\n     * @param {string} topicId - Topic ID. The topic ID subscribed to.\n     * @param {string[]} queries - Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of 100 queries are allowed, each 4096 characters long. You may filter on the following attributes: name, provider, type, enabled\n     * @param {string} search - Search term to filter your list results. Max length: 256 chars.\n     * @param {boolean} total - When set to false, the total count returned will be 0 and will not be calculated.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.SubscriberList>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    listSubscribers(topicId: string, queries?: string[], search?: string, total?: boolean): Promise<Models.SubscriberList>;\n    listSubscribers(\n        paramsOrFirst: { topicId: string, queries?: string[], search?: string, total?: boolean } | string,\n        ...rest: [(string[])?, (string)?, (boolean)?]    \n    ): Promise<Models.SubscriberList> {\n        let params: { topicId: string, queries?: string[], search?: string, total?: boolean };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string, queries?: string[], search?: string, total?: boolean };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string,\n                queries: rest[0] as string[],\n                search: rest[1] as string,\n                total: rest[2] as boolean            \n            };\n        }\n        \n        const topicId = params.topicId;\n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        const payload: Payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Create a new subscriber.\n     *\n     * @param {string} params.topicId - Topic ID. The topic ID to subscribe to.\n     * @param {string} params.subscriberId - Subscriber ID. Choose a custom Subscriber ID or a new Subscriber ID.\n     * @param {string} params.targetId - Target ID. The target ID to link to the specified Topic ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Subscriber>}\n     */\n    createSubscriber(params: { topicId: string, subscriberId: string, targetId: string  }): Promise<Models.Subscriber>;\n    /**\n     * Create a new subscriber.\n     *\n     * @param {string} topicId - Topic ID. The topic ID to subscribe to.\n     * @param {string} subscriberId - Subscriber ID. Choose a custom Subscriber ID or a new Subscriber ID.\n     * @param {string} targetId - Target ID. The target ID to link to the specified Topic ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Subscriber>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    createSubscriber(topicId: string, subscriberId: string, targetId: string): Promise<Models.Subscriber>;\n    createSubscriber(\n        paramsOrFirst: { topicId: string, subscriberId: string, targetId: string } | string,\n        ...rest: [(string)?, (string)?]    \n    ): Promise<Models.Subscriber> {\n        let params: { topicId: string, subscriberId: string, targetId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string, subscriberId: string, targetId: string };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string,\n                subscriberId: rest[0] as string,\n                targetId: rest[1] as string            \n            };\n        }\n        \n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n        const targetId = params.targetId;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        const payload: Payload = {};\n        if (typeof subscriberId !== 'undefined') {\n            payload['subscriberId'] = subscriberId;\n        }\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'post',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Get a subscriber by its unique ID.\n     * \n     *\n     * @param {string} params.topicId - Topic ID. The topic ID subscribed to.\n     * @param {string} params.subscriberId - Subscriber ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Subscriber>}\n     */\n    getSubscriber(params: { topicId: string, subscriberId: string  }): Promise<Models.Subscriber>;\n    /**\n     * Get a subscriber by its unique ID.\n     * \n     *\n     * @param {string} topicId - Topic ID. The topic ID subscribed to.\n     * @param {string} subscriberId - Subscriber ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Subscriber>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    getSubscriber(topicId: string, subscriberId: string): Promise<Models.Subscriber>;\n    getSubscriber(\n        paramsOrFirst: { topicId: string, subscriberId: string } | string,\n        ...rest: [(string)?]    \n    ): Promise<Models.Subscriber> {\n        let params: { topicId: string, subscriberId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string, subscriberId: string };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string,\n                subscriberId: rest[0] as string            \n            };\n        }\n        \n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n        }\n\n        return this.client.call(\n            'get',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n\n    /**\n     * Delete a subscriber by its unique ID.\n     *\n     * @param {string} params.topicId - Topic ID. The topic ID subscribed to.\n     * @param {string} params.subscriberId - Subscriber ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    deleteSubscriber(params: { topicId: string, subscriberId: string  }): Promise<{}>;\n    /**\n     * Delete a subscriber by its unique ID.\n     *\n     * @param {string} topicId - Topic ID. The topic ID subscribed to.\n     * @param {string} subscriberId - Subscriber ID.\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     * @deprecated Use the object parameter style method for a better developer experience.\n     */\n    deleteSubscriber(topicId: string, subscriberId: string): Promise<{}>;\n    deleteSubscriber(\n        paramsOrFirst: { topicId: string, subscriberId: string } | string,\n        ...rest: [(string)?]    \n    ): Promise<{}> {\n        let params: { topicId: string, subscriberId: string };\n        \n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {}) as { topicId: string, subscriberId: string };\n        } else {\n            params = {\n                topicId: paramsOrFirst as string,\n                subscriberId: rest[0] as string            \n            };\n        }\n        \n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        const payload: Payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n\n        const apiHeaders: { [header: string]: string } = {\n            'content-type': 'application/json',\n        }\n\n        return this.client.call(\n            'delete',\n            uri,\n            apiHeaders,\n            payload,\n        );\n    }\n}\n"]}